<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Gtk-Rust by Example</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="pages/1/index.html"><strong>1.</strong> Введение</a></li><li><a href="pages/2/hello_world.html"><strong>2.</strong> Hello World</a></li><li><a href="pages/3/index.html"><strong>3.</strong> Боксирующие кнопки</a></li><li><ul class="section"><li><a href="pages/3/objects.html"><strong>3.1.</strong> Упаковки, кнопки и метки</a></li><li><a href="pages/3/state.html"><strong>3.2.</strong> Сопровождение внешнего состояния</a></li><li><a href="pages/3/ui.html"><strong>3.3.</strong> Создание структуры UI</a></li><li><a href="pages/3/programming.html"><strong>3.4.</strong> Программирование UI</a></li><li><a href="pages/3/review.html"><strong>3.5.</strong> Заключение и обзор</a></li></ul></li><li><a href="pages/4/index.html"><strong>4.</strong> Составитель статей из HTML</a></li><li><ul class="section"><li><a href="pages/4/entries.html"><strong>4.1.</strong> Поля, панели, прокручиваемые окна</a></li><li><a href="pages/4/horrorshow.html"><strong>4.2.</strong> HTML-шаблоны Horrorshow</a></li><li><a href="pages/4/structure.html"><strong>4.3.</strong> Создание структуры UI</a></li><li><a href="pages/4/programming.html"><strong>4.4.</strong> Программирование UI</a></li><li><a href="pages/4/concl.html"><strong>4.5.</strong> Заключение и обзор</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Gtk-Rust by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#gtk-rust-на-примерах" id="gtk-rust-на-примерах"><h1>Gtk-Rust на примерах</h1></a>
<p>Gtk-Rust by Example (GRBE) представляет собой неофициальную книгу по разработке GTK GUI, на <a href="https://www.rust-lang.org/ru-RU/">языке программирования Rust</a>, которая будет демонстрировать практическое использование <a href="https://github.com/gtk-rs/gtk/">библиотеки GTK</a> на различных примерах.</p>
<p>Перед тем как начать, укажите версию библиотеки в вашем <code>Cargo.toml</code> файле:</p>
<pre><code>[dependencies.gtk]
version = &quot;0.3.0&quot;
features = [&quot;v3_22&quot;]
</code></pre>
<a class="header" href="print.html#Окно-с-панелью-заголовка" id="Окно-с-панелью-заголовка"><h1>Окно с панелью заголовка</h1></a>
<p><img src="img/hello_world.png" /></p>
<blockquote>
<p>Исходный код программы для этой главы можно найти <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/hello_world">здесь</a>.</p>
</blockquote>
<p>В этой главе мы создадим простое GTK приложение с панелью заголовка. Этот пример познакомит Вас с основами создания структуры приложения, которое будет содержать виджет и окно с заголовком.</p>
<a class="header" href="print.html#Создание-структуры-приложения" id="Создание-структуры-приложения"><h2>Создание структуры приложения</h2></a>
<p>Следующая диаграмма показывает, как мы будет проектировать структуру для нашего GTK приложения.
Можно и не следовать этой диаграмме для достижения главного результата, однако, проектирование структуры пользовательского интерфейса может быть полезной пищей для ума.</p>
<p><img src="img/diagram.png" /></p>
<p>В примере ниже, мы создадим структуру с <strong>GtkWindow</strong> и <strong>Header</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate gtk;

use gtk::*;

// Объявим структуру `Application`.
pub struct Application {
    pub window: Window,
    pub header: Header,
}
#}</code></pre></pre>
<p><strong>Header</strong> - это еще одна структура, которая будет содержать <strong>GtkHeaderbar</strong> и все виджеты внутри этой панели заголовка.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Объявим структуру `Header`.
pub struct Header {
    pub container: HeaderBar,
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-пользовательского-интерфейса-ui" id="Создание-пользовательского-интерфейса-ui"><h2>Создание пользовательского интерфейса (UI)</h2></a>
<p>Далее, мы создадим интерфейс с помощью Rust и расположим его в &quot;ново-объявленных&quot; структурах.</p>
<p>Во-первых, структура нашего приложения будет содержать в себе все другие структуры нашего пользовательского интерфейса. В примере ниже находится код с комментариями, описывающие каждый метод, который мы будем использовать для конфигурации.</p>
<p>Мы создадим <strong>GtkWindow</strong> и &quot;присоединим&quot; каждый элемент UI. Структура <code>Header</code> будет распологать в себе другие <strong>GtkHeaderBar</strong>. Далее, напишем функцию для выхода из приложения.
Важно также установить описание для окна и <code>wmclass</code>, который будет отображаться оконными менеджерами, а с помощью функции <code>Window::set_default_icon_name()</code> настроим отображаемую иконку.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Блок реализации.
impl Application {
    fn new() -&gt; Application {
        // Создадим новое окно с типом `Toplevel`.
        let window = Window::new(WindowType::Toplevel);
        // Создадим панель заголовка и связанный с ним контент.
        let header = Header::new();

        // Укажем название заголовка виджета.
        window.set_titlebar(&amp;header.container);
        // Укажем название для окна приложения.
        window.set_title(&quot;Простая программа&quot;);
        // Установим класс для оконного менеджера.
        window.set_wmclass(&quot;simple-gtk&quot;, &quot;Простая программа&quot;);
        // Установим иконку, отображаемую приложением.
        Window::set_default_icon_name(&quot;имя_иконки&quot;);

        // Программа закроется, если нажата кнопка выхода.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Возвращаем основное состояние приложения.
        Application { window, header }
    }
}
#}</code></pre></pre>
<p>Здесь распологается блок реализации для структуры <strong>Header</strong>, которая на данный момент содержит только <strong>GtkHeaderBar</strong>. Важно указать описание для этой панели заголовка, чтобы она отображалась, а также сделать активными элементы управления окном, поскольку они отключены по-умолчанию.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создадим виджет контейнера для главной панели заголовка.
        let container = HeaderBar::new();
        // Установим отображаемый тект в секции для названия.
        container.set_title(&quot;Simple GTK&quot;);
        // Делаем активными элементы управления окна в этой панели.
        container.set_show_close_button(true);

        // Возвращаем заголовок и его состояние.
        Header { container }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Инициализация-и-запуск-приложения" id="Инициализация-и-запуск-приложения"><h2>Инициализация и запуск приложения</h2></a>
<p>Теперь, когда мы готовы, нам нужно просто инициализировать GTK, создать структуру приложения, показать все виджеты внутри этой структуры и запустить главный цикл событий GTK.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Инициализация GTK.
    if gtk::init().is_err() {
        eprintln!(&quot;Не удалось инициализировать GTK приложение.&quot;);
        return;
    }

    // Инициализация начального состояния UI.
    let app = Application::new();

    // Делаем видимыми все виджеты с UI.
    app.window.show_all();

    // Запуск основного цикла GTK.
    gtk::main();
}
</code></pre></pre>
<p>После того, как основной поток вошёл в цикл событий, он будет взаимодействовать с каждым вызваным виджетом для действий, например: метод <code>connect_delete_event()</code>, который мы использовали выше, чтобы запрограммировать кнопку выхода для закрытия программы.</p>
<a class="header" href="print.html#Результат" id="Результат"><h2>Результат</h2></a>
<p>После того, как вы написали код, соберите и запустите программу, которая выглядит вот так:</p>
<pre><code class="language-bash">cargo build &amp;&amp; cargo run
</code></pre>
<p><img src="img/hello_world.png" /></p>
<a class="header" href="print.html#Боксирующие-кнопки" id="Боксирующие-кнопки"><h1>Боксирующие кнопки</h1></a>
<p><img src="img/btn_boxer.png" /></p>
<blockquote>
<p>Исходный код программы для этой главы можно найти <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/button_boxer">здесь</a>.</p>
</blockquote>
<p>В этом разделе мы рассмотрим, как структурировать Ваш UI с помощью <code>коробок</code>(box), изменять <code>метку</code>(label) и запрограммировать нажатие по кнопке. А также, к концу вы поймёте, как:</p>
<ol>
<li>Добавлять дочерние элементы в панель заголовка;</li>
<li>Добавлять классы стилей к кнопке;</li>
<li>Управлять состоянием приложения с помощью атомарных счётчиков <strong>Arc</strong> и выравнивать виджеты внутри контейнера.</li>
</ol>
<blockquote>
<p>Напомним, что каждый GTK объект, который можно получить из контейнера <strong>gtk</strong> - заворачивают,
так что не стоит беспокоится о правилах заимствования Rust. Объекты GTK считают ссылки,
поэтому, когда вам нужно передать GTK объект через несколько замыканий, вы можете
сделать это с помощью клонирования новой ссылки.</p>
</blockquote>
<a class="header" href="print.html#Необходимые-знания" id="Необходимые-знания"><h2>Необходимые знания</h2></a>
<p>Прежде чем продолжить изучение урока, убедитесь что вы понимаете что такое атомарность и атомарный счётчик ссылок (<strong>Arc</strong>). Эти понятия критически важны для возможности разделять состояние между несколькими замыканиями или потоками.
Изучить этот вопрос можно в документации модулей <code>std::sync</code> и <code>std::sync::atomic</code>. Так же, вы можете ознакомиться с безблокировочной конкурентностью (lockless concurrency) <a href="https://assets.bitbashing.io/papers/lockless.pdf">в этом документе</a>.</p>
<a class="header" href="print.html#Упаковки-кнопки-и-метки" id="Упаковки-кнопки-и-метки"><h1>Упаковки, кнопки и метки</h1></a>
<p>Цель этого раздела заключается в том, чтобы дать объяснение объектам, которые будут использованы до того, как мы применим их на практике в следующих разделах.</p>
<a class="header" href="print.html#gtkbox" id="gtkbox"><h2>GtkBox</h2></a>
<p><strong>GtkBox</strong> является фактически эквивалентом UI вектора в Rust и должена быть объявлена с помощью <strong>Orientation</strong>, который определяет, что должны ли элементы быть выровнены слева направо или сверху вниз. Для тех, кто имеет опыт разработки с современным дизайном HTML5/CSS3, <strong>GtkBox</strong> эквивалентен гибким упаковкам -- они могут расширяться на всё пространство, а виджеты, содержащиеся внутри, тоже могут расширяться в соответствии с правилами, применяемыми при дочерней упаковке.</p>
<a class="header" href="print.html#Создание-упаковки" id="Создание-упаковки"><h2>Создание упаковки</h2></a>
<p>В следующем примере, мы создадим горизонтальную и вертикальную упаковку с нулевым отступом между дочерними элементами, содержащимися в упаковке. После создания упаковки, вы можете задать виджеты, ипсользуя метод <code>pack_*</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let padding_between_children = 0;
let horizontal_box = Box::new(Orientation::Horizontal, padding_between_children);
let vertical_box = Box::new(Orientation::Vertical, padding_between_children);
#}</code></pre></pre>
<a class="header" href="print.html#Упаковка-упаковки" id="Упаковка-упаковки"><h2>Упаковка упаковки</h2></a>
<p>Вы могли заметить, что метод <code>pack_*</code> принимает большое количество параметров. Первым параметром должна быть ссылка на виджет, которую вы добавляете в контейнер. Вторым и третьим параметрами объявляют параметры заполнения соответственно. Последним параметром объявляют - как много единиц пространства должно быть между дочерними элементами в упаковке.</p>
<blockquote>
<p>To further elaborate on the expand and fill parameters, expand defines whether the
given widget should attempt to use all of the extra space that it can. Each widget that has
the expand parameter set will equally share that extra space. Meanwhile, fill defines whether
the extra spaced should actually have that widget fill to cover that extra space, or should
merely use that extra space as padding.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
health_info.pack_start(&amp;health_label, false, false, 5);
health_info.pack_start(&amp;health, true, true, 5);
#}</code></pre></pre>
<a class="header" href="print.html#gtklabel" id="gtklabel"><h2>GtkLabel</h2></a>
<p><strong>GtkLabel</strong> - это простой виджет, который состоит исключительно из текста. Название говорит само за себя. Всё, что вам нужно запомнить - это как создать метку(label) и изменить её.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let information_label = Label::new(&quot;Specific Information: &quot;);
let value = Label::new(&quot;Linux&quot;);
value.set_label(&quot;Redox&quot;);

let horizontal_box = Box::new(Orientation::Horizontal, 5);
horizontal_box.pack_start(&amp;information_label, false, false, 0);
horizontal_box.pack_start(&amp;value, true, false, 0);
#}</code></pre></pre>
<a class="header" href="print.html#gtkbutton" id="gtkbutton"><h2>GtkButton</h2></a>
<a class="header" href="print.html#Создание-кнопок" id="Создание-кнопок"><h3>Создание кнопок</h3></a>
<p><strong>GtkButton</strong> - это простая кнопка, содержащая текстовую метку(label) и/или изображения для представления действия, которое должно быть выполнено при нажатии кнопки.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let text_button = Button::new_with_label(&quot;Ok&quot;);
let image_button = Button::new_from_icon_name(&quot;имя-иконки&quot;, 32);
#}</code></pre></pre>
<a class="header" href="print.html#Дизайн-кнопок" id="Дизайн-кнопок"><h3>Дизайн кнопок</h3></a>
<p>Виджеты в GTK можно оформить так, чтобы они отличались от других виджетов в пользовательском интерфейсе(UI). В частности, кнопки поддерживают два класса стилей: destructive-action, and suggested-action. Если в вашем UI есть особенная кнопка, которая должна отличаться, вы можете установить её так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Добавьте соответствующие классы стилей к этим кнопкам.
delete_button.get_style_context().map(|c| c.add_class(&quot;destructive-action&quot;));
new_button.get_style_context().map(|c| c.add_class(&quot;suggested-action&quot;));
#}</code></pre></pre>
<p>Каждый <strong>GtkWidget</strong> предоставляет метод <strong>get_style_context()</strong>, который возвращает
<strong>Option<StyleContext></strong>, тем самым предоставляя метод <strong>add_class()</strong>, который используется чтобы установить класс стиля. Понимаете это? Хорошо. Наиболее важные классы кнопок, которые нужно знать - это <code>destructive-action</code> и <code>suggested-action</code>. Как правило, destructive action окрашивает кнопку в красный цвет, между тем, suggested action использует синий цвет. Актуальный цвет будет зависеть от того, какая тема GTK используется вами.</p>
<a class="header" href="print.html#Сопровождение-внешнего-состояния" id="Сопровождение-внешнего-состояния"><h1>Сопровождение внешнего состояния</h1></a>
<p>В этой главе у нас будет некоторое состояние, которым мы будем управлять с помощью UI. Поэтому нам необходим способ хранения и загрузки значения из этого состояния. Программа, которую мы хотим написать, имеет один компонент: значение здоровья.</p>
<p>Как оказалось, мы напрямую можем воспользоваться атомарными примитивами, таким как <strong>AtomicUsize</strong>, чтобы хранить значение для совместного использования нескольких неизменяемых замыканий. Этим атомарным значением можно управлять, не требуя изменяемого доступа к внутреннему значению. Таким образом, мы можем передавать неизменяемые ссылки на это значение и изменять его даже когда оно уже одолжено в нескольких местах одновременно.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct HealthComponent(AtomicUsize);
#}</code></pre></pre>
<p>Пока мы здесь, можем продолжить и написать некоторую логику для этой структуры в блоке реализации, используя следующие методы для здоровья:<code>initializing</code>,<code>subtracting</code> и <code>healing</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl HealthComponent {
    fn new(initial: usize) -&gt; HealthComponent { HealthComponent(AtomicUsize::new(initial)) }

    fn get_health(&amp;self) -&gt; usize { self.0.load(Ordering::SeqCst) }

    fn subtract(&amp;self, value: usize) -&gt; usize {
        let current = self.0.load(Ordering::SeqCst);
        let new = if current &lt; value { 0 } else { current - value };
        self.0.store(new, Ordering::SeqCst);
        new
    }

    fn heal(&amp;self, value: usize) -&gt; usize {
        let original = self.0.fetch_add(value, Ordering::SeqCst);
        original + value
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-структуры-пользовательского-интерфейса-ui" id="Создание-структуры-пользовательского-интерфейса-ui"><h1>Создание структуры пользовательского интерфейса (UI)</h1></a>
<p>Используя структуру предыдущей главы в качестве образца, мы можем расширить её, чтобы включить новые элементы UI, которые будем использовать в нашей программе. It is important to note that you only need to store elements that you are going to later program after the UI is constructed.</p>
<p>В этой программе мы добавим два <strong>GtkButtons</strong> к панели заголовка и воспользуемся вертикальной и горизонтальной <strong>GtkBox</strong> с некоторыми метками (labels), чтобы отобразить информацию о текущем состоянии нашего приложения. Следующее изображение является нашей новой диаграммой структур.</p>
<p><img src="img/btn_diagram.png" /></p>
<p>Что означает следующее в Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window:  Window,
    pub header:  Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub hit:       Button,
    pub heal:      Button,
}

pub struct Content {
    pub container: Box,
    pub health:    Label,
    pub message:   Label,
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-структуры-app" id="Создание-структуры-app"><h2>Создание структуры App</h2></a>
<p>Следуя последнему уроку, начнём с нашей структуры <strong>App</strong>. Метод <strong>new()</strong> должен принимать ссылку на <strong>&amp;HealthComponent</strong> в качестве вводимого значения в UI, later on
down the road within our <strong>Content</strong> structure. One will note that we have added a new
<strong>content</strong> variable of type <strong>Context</strong>, which takes that health reference.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl App {
    fn new(health: &amp;HealthComponent) -&gt; App {
        // Создадим новое окно с типом `Toplevel`.
        let window = Window::new(WindowType::Toplevel);
        // Создадим заголовок и связанное с ним содержимое.
        let header = Header::new();
        // Расположим содержимое в окне.
        let content = Content::new(health);

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Установим описание для окна.
        window.set_title(&quot;Боксирующие кнопки&quot;);
        // Установим класс для оконного менеджера.
        window.set_wmclass(&quot;app-name&quot;, &quot;Боксирующие кнопки&quot;);
        // Установим иконку, отображаемую приложением.
        Window::set_default_icon_name(&quot;имя-иконки&quot;);
        // Добавим коробку с содержимым в окно.
        window.add(&amp;content.container);

        // Запрограммируем выход из программы при нажатии кнопки.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Вернём состояние нашего приложения.
        App {
            window,
            header,
            content,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-header" id="Создание-header"><h2>Создание Header</h2></a>
<p>Затем мы так же реализуем метод для нашего заголовка, который должен содержать два элемента <strong>GtkButtons</strong> -- кнопка удара и лечения. Также обратите внимание, что мы устанавливаем некоторые классы стилей этим кнопкам, чтобы дать им более информативную визуальную способность.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создадим главный заголовочный бар содержащий виджет.
        let container = HeaderBar::new();

        // Установим текст для отображения в секции для названия.
        container.set_title(&quot;Боксирующие кнопки&quot;);
        // Сделаем активными элементы управления окна в этой панели.
        container.set_show_close_button(true);

        // Создадим кнопки: `ударить` и `лечить`.
        let hit = Button::new_with_label(&quot;Ударить&quot;);
        let heal = Button::new_with_label(&quot;Лечить&quot;);

        // Добавим соответствующие классы стилей к этим кнопкам.
        hit.get_style_context()
            .map(|c| c.add_class(&quot;destructive-action&quot;));
        heal.get_style_context()
            .map(|c| c.add_class(&quot;suggested-action&quot;));

        // Теперь добавим их в панель заголовка.
        container.pack_start(&amp;hit);
        container.pack_end(&amp;heal);

        // Вернём the header and all of it's state
        Header {
            container,
            hit,
            heal,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-content" id="Создание-content"><h2>Создание Content</h2></a>
<p>Теперь пришло время создать содержимое для нашего окна. При создании своего интерфейса (UI) с древовидной диаграммой, вы почти достигните <strong>GtkBoxes</strong>. При инициализации, эта упаковка должна быть указана с <strong>Horizontal</strong> или  <strong>Vertical</strong> оринтацией.</p>
<p>You will amost certainly reach for <strong>GtkBoxes</strong> for configuring your UI. These can be created with either a <strong>Horizontal</strong> or <strong>Vertical</strong> alignment. These boxes are where you will add all of your widgets, where they will be stacked according to the alignment of the box they are attached to.</p>
<p>Мы должны создать вертикальную упаковку, которая содержит два дочерних элемента: вертикальный <strong>GtkBox</strong> содержащий метку (label) и значение, а затем ниже простой <strong>GtkLabel</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new(health: &amp;HealthComponent) -&gt; Content {
        // Создадим вертикальную упаковку, чтобы хранить там все дочерние элементы.
        let container = Box::new(Orientation::Vertical, 0);

        // Информация о здоровье будет храниться в горизонтальной упаковке вместе с вертикальной.
        let health_info = Box::new(Orientation::Horizontal, 0);
        let health_label = Label::new(&quot;Текущее значение здоровья:&quot;);
        let health = Label::new(health.get_health().to_string().as_str());

        // Установим горизонтальное выравнивание для наших объектов.
        health_info.set_halign(Align::Center);
        health_label.set_halign(Align::Start);
        health.set_halign(Align::Start);

        // Добивим информацию о здоровье в дочернюю коробку.
        health_info.pack_start(&amp;health_label, false, false, 5);
        health_info.pack_start(&amp;health, true, true, 5);

        /*
         *   Создадим метку, которая будет изменяться приложением
         *   при выполнении удара или лечения.
         */
        let message = Label::new(&quot;Привет&quot;);

        // Добавим все в нашу вертикальную коробку.
        container.pack_start(&amp;health_info, true, false, 0);
        container.pack_start(&amp;Separator::new(Orientation::Horizontal), false, false, 0);
        container.pack_start(&amp;message, true, false, 0);

        Content {
            container,
            health,
            message,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Устанавливаем-выравнивание" id="Устанавливаем-выравнивание"><h3>Устанавливаем выравнивание</h3></a>
<p>Возможно, вы заметили, что приведённый код выше устанавливает горизонтальные выравнивания.
По желанию, с помощью методов <code>set_halign()</code> и <code>set_valign()</code>, можно установить выравнивание для виджетов.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Установим горизонтальное выравнивание для наших объектов.
health_info.set_halign(Align::Center);
health_label.set_halign(Align::Start);
health.set_halign(Align::Start);
#}</code></pre></pre>
<a class="header" href="print.html#Программирование-ui" id="Программирование-ui"><h1>Программирование UI</h1></a>
<p>На этом этапе, мы сможем соединить всё вместе. Сначала мы установим стандартное значение здоровья для программы. Это значение будет использоваться для инициализации состояния структуры приложения. Затем, мы напишем код для кнопки удара и лечения, которые будут должны изменять значение содержимого в главном окне.</p>
<a class="header" href="print.html#Перед-тем-как-мы-начнём" id="Перед-тем-как-мы-начнём"><h2>Перед тем, как мы начнём</h2></a>
<p>В нашем распоряжении будет несколько строк, которые будут использованы взависимости от действия. Это массив <strong>MESSAGES</strong>, к которому мы будем обращатся с помощью типажа с типом <strong>u8</strong>, который будет использован для получения индексов в массиве.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Заданные сообщения, которые будут использоваться в UI
// при определённых условиях.
const MESSAGES: [&amp;str; 3] = [&quot;Ой! Ты ударил меня!&quot;, &quot;...&quot;, &quot;Спасибо!&quot;];

#[repr(u8)]
// Типаж с типом `u8`, который используется как индекс в массиве `MESSAGES`.
enum Message { Hit, Dead, Heal }
#}</code></pre></pre>
<p>Для тех, кто плохо разбирается в Rust, атрибут <code>#[repr(u8)]</code> определяет, что следующие элементы будут представлены типом <strong>u8</strong> в памяти. По умолчанию, варианты для типажей начинаются с нуля, поэтому <strong>Hit</strong> это <code>0</code>, тогда как <strong>Heal</strong> это <code>2</code>. Если вы хотите сделать это явным, вы можете написать это как:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
enum Message { Hit = 0, Dead = 1, Heal = 2 }
#}</code></pre></pre>
<a class="header" href="print.html#Инициализация-компонента-health-и-структурирование-приложения" id="Инициализация-компонента-health-и-структурирование-приложения"><h2>Инициализация компонента Health и структурирование приложения</h2></a>
<p>После инициализации GTK, мы можем создать наш компонент <code>health</code>, который будет обёрнут внутри атомарного счётчика (<strong>Arc</strong>). Если вы запомнили предыдущий код, то на самом деле внутреннее значение это <strong>AtomicUsize</strong>, который служит нашим счетчиком <code>health</code>. Это значение будет передаваться через несколько замыканий, следовательно требуется для счётчика ссылок.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let health = Arc::new(HealthComponent::new(10));
#}</code></pre></pre>
<p>Используя это значение, мы создадим структуру UI нашего приложения. Обратите внимание, что <code>&amp;health</code> автоматически ссылается как <strong>&amp;HealthComponent</strong>, даже если завёрнут в <strong>Arc</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = App::new(&amp;health);
#}</code></pre></pre>
<a class="header" href="print.html#Запрограммируем-кнопку-удара" id="Запрограммируем-кнопку-удара"><h2>Запрограммируем кнопку удара</h2></a>
<p>Находясь здесь, всё что нам надо - это написать код наших виджетов. Именно здесь мы будем передавать оба компонента <code>health</code> и другие различные виджеты UI через замыкания. Начнём с кнопки лечения. Нам просто нужно сказать программе: &quot;Что произойдет при нажатии на кнопку&quot; ?
Типаж <strong>ButtonExt</strong> предоставляет метод <strong>connect_clicked()</strong> именно для этого.</p>
<blockquote>
<p>Обратите внимание, что виджеты в GTK обычно проходят через их замыкания, поэтому, если
вы хотите управлять вызовом виджета, вы можете сделать это используя выбранное значение
через замыкание. Мы не нуждаемся в этой функциональности, поэтому просто проигнорируем
зачение.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
widget.connect_action(move |widget| {});
#}</code></pre></pre>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Запрограммируем кнопку `Ударить` чтобы уменьшить здоровье.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.hit.clone().connect_clicked(move |_| {
        let new_health = health.subtract(1);
        let action = if new_health == 0 { Message::Dead } else { Message::Hit };
        message.set_label(MESSAGES[action as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}
#}</code></pre></pre>
<p>В коде выше, мы создали анонимную область, чтобы мы могли содержать наши клонированные ссылки.
Каждый вызов <strong>clone()</strong> просто увеличивает счётчик ссылок и делает значние доступным,
чтобы использовать его еще раз позже.</p>
<p>После вычитания из компонента health, если health равен <code>0</code>, то мы должны вернуть <strong>Message::Dead</strong>, иначе, сообщением будет <strong>MessageHit</strong>. После того, как мы овладели этой информацией, это просто вопрос обновления метки с новым значением.</p>
<a class="header" href="print.html#Запрограммируем-кнопку-лечения" id="Запрограммируем-кнопку-лечения"><h2>Запрограммируем кнопку лечения</h2></a>
<p>Это работает почти также, поэтому мы можем скопировать и вставить код выше, а затем изменить его, чтобы удовлетворить наши потребности.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Запрограммируем кнопку `Лечить`, чтобы вернуть очки здоровья.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.heal.clone().connect_clicked(move |_| {
        let new_health = health.heal(5);
        message.set_label(MESSAGES[Message::Heal as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}
#}</code></pre></pre>
<a class="header" href="print.html#В-общей-сложности" id="В-общей-сложности"><h2>В общей сложности</h2></a>
<p>После программирования UI, вы можете завершить код, выполнив следующее:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Сделаем все виджеты видимыми в UI.
app.window.show_all();

// Запуск основного цикла GTK.
gtk::main();
#}</code></pre></pre>
<p>Ваш исходный код должен быть таким:</p>
<pre><pre class="playpen"><code class="language-rust">// Заданные сообщения, которые будут использоваться в UI
// при определённых условиях.
const MESSAGES: [&amp;str; 3] = [&quot;Ouch! You hit me!&quot;, &quot;...&quot;, &quot;Thanks!&quot;];

#[repr(u8)]
// Типаж с типом `u8`, который используется как индекс в массиве `MESSAGES`.
enum Message { Hit, Dead, Heal }

fn main() {
    // Инициализируем GTK перед продолжением.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    /*  Установим начальное состояние для нашего компонента - `health`.
     *   Воспользуемся `Arc`, для того, чтобы мы могли
     *   использовать несколько programmable замыканий.
     */
    let health = Arc::new(HealthComponent::new(10));

    // Инициализируем начальное состояние UI.
    let app = App::new(&amp;health);

    {
        // Запрограммируем кнопку `Ударить` чтобы уменьшить здоровье.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.hit.clone().connect_clicked(move |_| {
            let new_health = health.subtract(1);
            let action = if new_health == 0 { Message::Dead } else { Message::Hit };
            message.set_label(MESSAGES[action as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    {
        // Запрограммируем кнопку `Лечить`, чтобы вернуть очки здоровья.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.heal.clone().connect_clicked(move |_| {
            let new_health = health.heal(5);
            message.set_label(MESSAGES[Message::Heal as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    // Сделаем все виджеты видимыми в UI.
    app.window.show_all();

    // Запуск основного цикла GTK.
    gtk::main();
}
</code></pre></pre>
<a class="header" href="print.html#Заключение-и-обзор" id="Заключение-и-обзор"><h2>Заключение и обзор</h2></a>
<p>Если вы нажмёте на кнопку <code>Ударить</code>, счётчик должен уменьшиться и сообщение должно измениться. Нажатие по кнопке <code>Лечить</code> должно  увеличить счётчик и также изменить сообщение.После запуска вашей программы с помощью <code>cargo run</code>, вы должны увидеть окно, которое выглядит так:</p>
<p><img src="img/btn_boxer.png" /></p>
<p>На этом этапе, вы должны хорошо понимать как работают: <strong>GtkBox</strong>, <strong>GtkButton</strong> и <strong>GtkLabel</strong>. Вы можете вернуться к предыдущему разделу, чтобы ещё раз уточнить некоторые моменты.</p>
<a class="header" href="print.html#Практическое-занятие" id="Практическое-занятие"><h2>Практическое занятие</h2></a>
<a class="header" href="print.html#setting-inputs-w-buttons" id="setting-inputs-w-buttons"><h3>Setting Inputs w/ Buttons</h3></a>
<p>There isn't much that you can do with just buttons and labels. If you want a practice challenge, try creating a program that displays a simple random math problem, and asks the user to use buttons to set the value. If they get it correct, modify a label to tell the user that what they entered was correct. This is an incredibly annoying interface design, so don't do this in the real world!
Bonus: Timed Answers</p>
<p>Do the same as the above, but also take advantage of <code>gtk::timeout_add()</code> to decrement and update a timer label within the UI until the timer reaches zero.</p>
<a class="header" href="print.html#Составитель-статей-из-html" id="Составитель-статей-из-html"><h1>Составитель статей из HTML</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<blockquote>
<p>Исходный код для этой главы находится <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/html_article">здесь</a>.</p>
</blockquote>
<p>В данной главе вы начнете писать полезные программы, используя поля для ввода
и просмотра текста, для того чтобы дать возможность пользователю вводить нужные
значения в текстовые поля и генерировать выходные значения из введенных
значений после нажатия на кнопку. В добавок вы познакомитесь с
макроопределением <code>html!</code>, который находится внутри пакета <em>horrorshow</em>. Вы
будете писать программу, которая принимает введенные значения на левой панели
и генерирует HTML на правом поле для просмотра текста.</p>
<blockquote>
<p>Обратите внимание на то что, что в данной главе мы не рассматриваем вопрос
хранения данных во внешнем источнике, как это было в прошлой главе. Все состояние,
которое нас интересует, находится внутри GTK объектов, с которыми мы будем
взаимодействовать.</p>
</blockquote>
<a class="header" href="print.html#Поля-панели-прокручиваемые-окна-и-просмотр-текста" id="Поля-панели-прокручиваемые-окна-и-просмотр-текста"><h1>Поля, панели, прокручиваемые окна и просмотр текста</h1></a>
<a class="header" href="print.html#gtkpaned" id="gtkpaned"><h2>GtkPaned</h2></a>
<p>Это контейнеры, которые могут быть ориентированы вертикально или горизонтально,
представляют собой два элемента, размер которых может изменяться.
Размер этих двух элементов может быть изменен простым нажатием и перемещением
разделяющей полосы между ними.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let container = Paned::new(Orientation::Horizontal);
let left_widget = ...;
let right_widget = ...;
container.pack1(&amp;left_widget, true, true);
container.pack2(&amp;right_widget, true, true);
#}</code></pre></pre>
<a class="header" href="print.html#gtkentry" id="gtkentry"><h2>GtkEntry</h2></a>
<p>Элементы позволяют пользовательскому интерфейсу принимать строку текста как
входное значение, что может быть использовано другими виджетами для выполнения
некоторых действий, используя данный текст как входные данные.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let entry = Entry::new();
entry.set_text(&quot;Some Text&quot;);
if let Some(text) = entry.get_text() {
    println!(&quot;{}&quot;, text);
}
#}</code></pre></pre>
<a class="header" href="print.html#gtktextview" id="gtktextview"><h2>GtkTextView</h2></a>
<p>Текстовые панели нужны для двух вещей:</p>
<ul>
<li>способность показывать многострочный текст</li>
<li>возможность пользователю вводить многострочный текст
Текстовая панель может быть настроена так, что ее содержимое нельзя
редактировать, если есть такая необходимость. Также есть возможность
настраивать работу с переносами текста. Текстовые панели не умеют работать
с форматированным текстом, однако вполне могут быть использованы как
редактор кода. Если вы хотите, чтобы текст был показан в виде HTML, смотрите
<strong>GtkWebView</strong>, если же вы хотите получить редактор кода, смотрите
<strong>GtkSourceView</strong>.</li>
</ul>
<blockquote>
<p>Заметьте, что часто бывает лучше создать и привязать <strong>GtkTextBuffer</strong>
к вашему текстовому полю вручную, чтобы получить указатель на буфер,
который вы можете хранить, и избежать непрямого обращения, когда вы
программируете ваш пользовательский интерфейс (UI). Имея указатель на буфер,
можно легко получить доступ к тексту, который содержится в текстовой панели.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Буфер для текстовой панели с None в качестве параметра, потому что мы не
// собираемся определять никаких текстовых тэгов для этого буфера.
let text_buffer = TextBuffer::new(None);
// После этого мы должны присвоить буфер новой текстовой панели, которая будет
// самостоятельно обновлять себя при добавлении или удалении текста из буфера.
let text_view = TextView::new_with_buffer(&amp;text_buffer);
#}</code></pre></pre>
<p>Извлечение текста из <strong>GtkTextBuffer</strong> требует некоторой сноровки, так что
мы привели пример функции, которую вы можете использовать для того, чтобы
получить содержимое буфера в виде строки (String). Вы можете указать
определенный участок текста, который будет извлечен из буфера.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Получить все содержимое буфера в строковом представлении.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}
#}</code></pre></pre>
<a class="header" href="print.html#gtkscrolledwindow" id="gtkscrolledwindow"><h2>GtkScrolledWindow</h2></a>
<p>Это одноэлементные контейнеры которые предоставляют прокручиваемые окна внутри
них. Часто бывает удобным сочетать их вместе с текстовыми полями, которые
возможно прокручивать. Это как раз то, что мы хотим сделать в этой главе.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let scrolled_window = ScrolledWindow::new(None, None);
scrolled_window.add(&amp;text_view);
#}</code></pre></pre>
<a class="header" href="print.html#horrorshow-html-шаблоны" id="horrorshow-html-шаблоны"><h1>Horrorshow HTML-шаблоны</h1></a>
<p>Хотя это и не связано с разработкой c использованием GTK, пакет horrorshow
предотавляет удобные макроопределения, которые дают возможность эффективно
генерировать HTML-строки в памяти, используя DSL (<em>domain-specific language</em>)
совместно с Rust, который может быть запущен посредством использования символа
(<em>sigil</em>) <code>@</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate horrorshow;
use horrorshow::helper::doctype;

let title = &quot;Title&quot;;
let content = &quot;A string\nwith multiple\n\nlines&quot;;
let html_string = format!(
    &quot;{}&quot;,
    html!{
        : doctype::HTML,
        html {
            head {
                style { : &quot;#style { }&quot; }
            }
            body {
                h1(id=&quot;style&quot;) { : title }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
);
#}</code></pre></pre>
<a class="header" href="print.html#Создаем-структуру-ui" id="Создаем-структуру-ui"><h1>Создаем структуру UI</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<p>Используя первую главу как шаблон и расширяя его, мы должны
продумать дизайн пользовательского интерфейса согласно нашему
видению UI, который представлен выше.</p>
<p>Основные элементы интерфейса, которые стоит взять на заметку - это кнопка
<strong>Post</strong> в заголовочной панели. Внутри нашего окна содержимым содержится
элемент <strong>title</strong>, элемент <strong>tags</strong>, текстовая панель <strong>content</strong> и
текстовая панель <strong>right_pane</strong> для отображения текста в виде HTML-разметки.
Таким образом, структура нашего пользовательского интерфейса выглядит так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window: Window,
    pub header: Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub post: Button
}

pub struct Content {
    pub container: Paned,
    pub title: Entry,
    pub tags: Entry,
    pub content: TextBuffer,
    pub right_pane: TextBuffer,
}
#}</code></pre></pre>
<p>Заметьте, что контейнер для нашего содержимого будет расположен не в <strong>GtkBox</strong>,
а в <strong>GtkPaned</strong>. Это позволит пользователю перемещать разграничительную полосу
между панелями для того чтобы менять размер панелей по своему усмотрению.
В добавок поля <strong>content</strong> и <strong>right_pane</strong> хранятся как <strong>GtkTextBuffer</strong>,
а не как <strong>GtkTextViews</strong>. Это потому, что мы не будет программировать
панели для просмотра, но будем использовать лежащие в их основе текстовые
буферы, которые связаны с этими панелями.</p>
<a class="header" href="print.html#Написание-программы" id="Написание-программы"><h2>Написание программы</h2></a>
<p>Новым здесь будет то, что мы определим для окон размер по умолчанию, потому
что мы должны иметь разумный размер, с которым пользователь будет
взаимодействовать по умолчанию, чтобы пользователю не приходилось менять размер
окна, чтобы удобнее обозревать его содержимое. Мы также изменяем заголовок на
&quot;HTML Articler&quot;. Кроме этого, все остально должно быть похоже на то, как вы
разрабатываете другие приложения.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl App {
    fn new() -&gt; App {
        // Создадим новое окно верхнего уровня.
        let window = Window::new(WindowType::Toplevel);
        // Создадим заголовочную панель и связанное с ней содержимое.
        let header = Header::new();
        // Создадим элемент для хранения содержимого.
        let content = Content::new();

        // Сделаем заголовочную панель виджетом в панели с названием.
        window.set_titlebar(&amp;header.container);
        // Установим название окна.
        window.set_title(&quot;HTML Articler&quot;);
        // Установим управляющий класс для окна.
        window.set_wmclass(&quot;html-articler&quot;, &quot;HTML Articler&quot;);
        // Иконка, которую программа будет показывать.
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Установить размер окна по умолчанию.
        window.set_default_size(800, 600);
        // Добавим содержимое в окно.
        window.add(&amp;content.container);

        // Запрограммируем, что делать, когда нажата кнопка выхода.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Возвратим главное состояние приложения.
        App { window, header, content }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Реализация-заголовка" id="Реализация-заголовка"><h2>Реализация заголовка</h2></a>
<p>Наша заголовочная панель будет иметь кнопку с надписью <strong>Post</strong>, которая
получит <em>CSS</em>-стиль 'suggested-action' и будет расположена в конце панели.
Название заголовочной панели должна совпадать с именем нашего приложения.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создает контейнер для хранения виджета - заголовочной панели.
        let container = HeaderBar::new();

        // Устанавливает текст для показа в области названия в заголовочной панели.
        container.set_title(&quot;HTML Articler&quot;);
        // Установим элементы управления в области заголовочной панели.
        container.set_show_close_button(true);

        // Создадим кнопку, которая будет выводить HTML-статью.
        let post = Button::new_with_label(&quot;Post&quot;);
        post.get_style_context().map(|x| x.add_class(&quot;suggested-action&quot;));

        container.pack_end(&amp;post);

        // Возвратим заголовок и все его состояние.
        Header { container, post }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Реализация-содержимого" id="Реализация-содержимого"><h2>Реализация содержимого</h2></a>
<p>Это то место, где мы будет тратить большую часть нашего времени, находясь
в приложении. Во-первых, создадим контейнер <strong>GtkPaned</strong>, который будет
содержать левую и правую панели, размер которых изменяем. Нашей правой панелью
будет <strong>GtkTextView</strong>, а правой будет вертикальный <strong>GtkBox</strong>. Заметьте,
мы заинтересованы в том, чтобы получить прямой доступ к тексту внутри буфера
панели для просмотра, так что буфер мы инициализируем перед созданием панели.
Контейнер левой панели будет содержать отступ в <code>5</code> условных единицах,
чтобы они не слеплялись вместе.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Главный контейнер будет содержать левую и правую панели. Левая панели
// предназначена для пользовательского ввода, в то время как правая
// предназначена для показа сгенерированных выходных данных.
let container = Paned::new(Orientation::Horizontal);
let left_pane = Box::new(Orientation::Vertical, 5);
let right_pane = TextBuffer::new(None);
let right_pane_view = TextView::new_with_buffer(&amp;right_pane);
#}</code></pre></pre>
<p>После этого мы создаем элементы <strong>title</strong> и <strong>tags</strong>, в добавок создадим
панель <strong>content</strong>, которую мы будем использовать для построения левой панели.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Левая панель будет состоять из заголовка, элемента с тэгами и текстовой
// панели для просмотра содержимого.
let title = Entry::new();
let tags = Entry::new();
let content = TextBuffer::new(None);
let content_view = TextView::new_with_buffer(&amp;content);
#}</code></pre></pre>
<p>Заметьте, мы также должны хранить размещенную по центру надпись над текстовой
панелью <strong>content</strong>, после которой мы добавим немного заполняющего текста
в элементах, и пояснительные подсказки, которые будут показываться, при наведении
мыши на элементы.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Метка, которую мы будет показывать над элементом с содержимым
// для его описания.
let content_label = Label::new(&quot;Content&quot;);
content_label.set_halign(Align::Center);

// Показывать пользователю текстовые подсказки в полях для ввода. 
title.set_placeholder_text(&quot;Insert Title&quot;);
tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

// Показывать всплывающие подсказки пользователю, которые будут
// проявляться при наведении мыши.
title.set_tooltip_text(&quot;Insert the title of article here&quot;);
tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);
#}</code></pre></pre>
<p>После этого сделаем так, чтобы текстовое поле на правой панели не разрешало
редактирование, и оба текстовых поля должны содержать в себе текст, в которым
переносы произведены по словам (а не по слогам).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Правая панель не должна разрешать изменять ее содержимое, и оба редактора
// должны производить перенос по целым словам (а не по слогам).
right_pane_view.set_editable(false);
right_pane_view.set_wrap_mode(WrapMode::Word);
content_view.set_wrap_mode(WrapMode::Word);
#}</code></pre></pre>
<p>Сейчас мы должны переносить текстовые поля внутри <strong>GtkScrolledWindows</strong> для
того, чтобы позволить пользователю прокручивать текст, на тот случай, если
имеется больше текста, чем доступно места для просмотра внутри элемента.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Произвести необходимые переносы текста в прокручиваемых окнах.
let content_scroller = ScrolledWindow::new(None, None);
let right_pane_scrolled = ScrolledWindow::new(None, None);
content_scroller.add(&amp;content_view);
right_pane_scrolled.add(&amp;right_pane_view);
#}</code></pre></pre>
<p>Для того, чтобы улучшить пользовательский интерфейс, мы можем добавить поля и
границы.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Настраиваем поля.
left_pane.set_border_width(5);
right_pane_view.set_left_margin(5);
right_pane_view.set_right_margin(5);
right_pane_view.set_top_margin(5);
right_pane_view.set_bottom_margin(5);
content_view.set_left_margin(5);
content_view.set_right_margin(5);
content_view.set_top_margin(5);
content_view.set_bottom_margin(5);
#}</code></pre></pre>
<p>И все, что остается - поместить элеметы внутри соответствующих панелей
и вернуть структуру <strong>Content</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Сначала добавим все в левую панель.
left_pane.pack_start(&amp;title, false, true, 0);
left_pane.pack_start(&amp;tags, false, true, 0);
left_pane.pack_start(&amp;content_label, false, false, 0);
left_pane.pack_start(&amp;content_scroller, true, true, 0);

// После этого добавьте правую и левую панели в контейнер.
container.pack1(&amp;left_pane, true, true);
container.pack2(&amp;right_pane_scrolled, true, true);

Content { container, title, tags, content, right_pane }
#}</code></pre></pre>
<p>Собирая все вместе, мы должны получить следующую реализацию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new() -&gt; Content {
        // Главный контейнер будет содержать левую и правую панели. Левая панель
        // предназначена для пользовательского ввода, а левая панель
        // предназначена для сгенерированных данных.
        let container = Paned::new(Orientation::Horizontal);
        let left_pane = Box::new(Orientation::Vertical, 5);
        let right_pane = TextBuffer::new(None);
        let right_pane_view = TextView::new_with_buffer(&amp;right_pane);

        //Левая панель будет состоять из заголовка, элементов с тэгами и
        // текстовой панели для просмотра содержимого.
        let title = Entry::new();
        let tags = Entry::new();
        let content = TextBuffer::new(None);
        let content_view = TextView::new_with_buffer(&amp;content);

        // Метка, которую мы будем показывать над содержимым для его описания.
        let content_label = Label::new(&quot;Content&quot;);
        content_label.set_halign(Align::Center);

        // Показывать пользователю текстовые подсказки в полях для ввода.
        title.set_placeholder_text(&quot;Insert Title&quot;);
        tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

        // Показывать всплывающие подсказки пользователю, которые будут
        // проявляться при наведении мыши.
        title.set_tooltip_text(&quot;Insert the title of article here&quot;);
        tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);

        // Правая панель не должна разрешать изменять ее содержимое, и оба редактора
        // должны производить перенос по целым словам (а не по слогам).
        right_pane_view.set_editable(false);
        right_pane_view.set_wrap_mode(WrapMode::Word);
        content_view.set_wrap_mode(WrapMode::Word);

        // Произвести необходимые переносы текста в прокручиваемых окнах.
        let content_scroller = ScrolledWindow::new(None, None);
        let right_pane_scrolled = ScrolledWindow::new(None, None);
        content_scroller.add(&amp;content_view);
        right_pane_scrolled.add(&amp;right_pane_view);

        // Настраиваем отступы.
        left_pane.set_border_width(5);
        right_pane_view.set_left_margin(5);
        right_pane_view.set_right_margin(5);
        right_pane_view.set_top_margin(5);
        right_pane_view.set_bottom_margin(5);
        content_view.set_left_margin(5);
        content_view.set_right_margin(5);
        content_view.set_top_margin(5);
        content_view.set_bottom_margin(5);

        // Сначала добавим все в левую панель.
        left_pane.pack_start(&amp;title, false, true, 0);
        left_pane.pack_start(&amp;tags, false, true, 0);
        left_pane.pack_start(&amp;content_label, false, false, 0);
        left_pane.pack_start(&amp;content_scroller, true, true, 0);

        // После этого добавьте правую и левую панели в контейнер.
        container.pack1(&amp;left_pane, true, true);
        container.pack2(&amp;right_pane_scrolled, true, true);

        Content { container, title, tags, content, right_pane }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Программирование-ui-1" id="Программирование-ui-1"><h1>Программирование UI</h1></a>
<p>Теперь, когда имеются виджеты, которые должны взаимодействовать друг с другом,
вы можете подумать, что данная часть является небольшой, но сложной в реализации.
Если вы так думаете, то вы полностью ошибаетесь, потому что данная часть будет
самой легкой частью программы для реализации. Начнем с функции <code>main</code>, которую
мы возьмем из первой главы в качестве шаблона.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Инициализация GTK перед началом работы.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Инициализация начального состояния пользовательского интерфейса.
    let app = App::new();

    // Напишите код работы ваших виджетов здесь.

    // Сделать видимыми все виджеты пользовательского интерфейса
    app.window.show_all();

   // Запустим главный цикл событий (_event loop_) GTK.
    gtk::main();
}
</code></pre></pre>
<p>Мы запрограммируем кнопку <strong>Post</strong> так, чтобы она принимала элементы <strong>title</strong>
и <strong>tags</strong>, также как и буфер текстовой панели <strong>content</strong>. Далее мы пропустим
строки из этих виджетов через HTML-макроопределение <em>horrorshow</em> и напишем
получившийся результат в текстовый буфер <strong>right_pane</strong>. Код для программирования
кнопки выглядит так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Программирование кнопки **Post** на принятие входных значений из
    // левой панели, произведение необходимого обновление HTML-кода на
    // правой панели. Подготовка к увеличение значения счетчиков...
    let title = app.content.title.clone();
    let tags = app.content.tags.clone();
    let content = app.content.content.clone();
    let right_pane = app.content.right_pane.clone();
    app.header.post.connect_clicked(move |_| {
        let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
        if let (Some(title), Some(tags), Some(content)) = inputs {
            right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
        }
    });
}
#}</code></pre></pre>
<p>Заметьте, получить текста из элемента очень просто. Для этого нужно всего лишь
вызвать метод <strong>get_text()</strong>, который возвращает <strong>Option<String></strong>. Получение
текста из текстового буфера немного сложнее, поэтому вам необходимо использовать
функцию, которая была рекомендована в начале этой главы. Эта функция написана так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Получить содержимое текстового буфера в виде строки.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}
#}</code></pre></pre>
<p>Вы также заметите интересный шаблон проектирования (паттерн) в Rust, которая
сильно упростила нам проверку наличия всех входных данных при получение входных
данных, все это произошло перед тем как что-то сделали с входными значениями.
Синтаксис <strong>if let</strong> в Rust работает не только с шаблонами (паттернами),
но и с кортежами (<em>tuple</em>), так что вы можете проверять несколько входных
данных в кортеже одновременно, так же, как вы бы делали это в <strong>match</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
if let (Some(title), Some(tags), Some(content)) = inputs {
    right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
}
#}</code></pre></pre>
<p>Нам еще предстоит определить функцию <strong>generate_html</strong>, и это будет
завершающей частью реализации приложения. Самым простым способом
использования макроопределения <strong>html!</strong> является его подстановка в качестве
аргумента в макроопределение <strong>format!</strong>. Наша функция будет выглядеть так,
хотя вы вольны реализовать HTML-макроопределение по своему усмотрению.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Генерирует HTML, который будет показан на правой панели.
fn generate_html(title: &amp;str, tags: &amp;str, content: &amp;str) -&gt; String {
    format!{
        &quot;{}&quot;,
        html!{
            article {
                header {
                    h1 { : &amp;title }
                    div(class=&quot;tags&quot;) {
                        @ for tag in tags.split(':') {
                            div(class=&quot;tag&quot;) { : tag }
                        }
                    }
                }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
}
#}</code></pre></pre>
<p>Синтаксис приведенного выше кода должен быть довольно читаемым. Мы создаем
пару тэгов <strong>article</strong>, которая содержит в себе пару тэгов <strong>header</strong> и
параграф <strong>p</strong> для каждой непустой линии из входных данных, полученных из
текстового буфера <strong>content</strong>. Внутри тэгов <strong>header</strong> есть заголовок <strong>h1</strong>,
который использует текст из поля для ввода названия как свой текст. Также там
есть элемент <strong>div</strong>, который содержит список тэгов, разделенных двоеточиями.
<img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<p>Имея все это на своих местах, у вас должна получиться работающая программа,
выглядящая как на изображении.</p>
<a class="header" href="print.html#Заключение-и-обзор-1" id="Заключение-и-обзор-1"><h1>Заключение и обзор</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<p>К данному времени у вас должно сложиться хорошее представление о том, как писать
программы с использованием библиотеки GTK на Rust. К текущему моменту вы должны
знать, как делать следующее:</p>
<ul>
<li>создавать, получать, присваивать значения объектам <strong>Label</strong></li>
<li>создавать, получать, присваивать значения объектам <strong>Entries</strong></li>
<li>создавать, получать, присваивать значения объектам <strong>TextBuffer</strong></li>
<li>создавать, присваивать буферы объектам <strong>TextViews</strong></li>
<li>создавать, настраивать стили внешнего вида, программировать объекты <strong>Button</strong></li>
<li>присваивать элементы объектам <strong>Box</strong> и контейнерам <strong>Paned</strong></li>
<li>устанавливать отступы и поля на виджетах</li>
<li>работать с внешним состоянием</li>
</ul>
<a class="header" href="print.html#Практические-задачи" id="Практические-задачи"><h2>Практические задачи</h2></a>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
