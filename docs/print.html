<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Gtk-Rust by Example</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li class="affix"><a href="pages/index.html">Введение</a></li><li><a href="pages/hello_world.html"><strong>1.</strong> Hello World</a></li><li><a href="pages/btn_boxer/index.html"><strong>2.</strong> Боксирующие кнопки</a></li><li><ul class="section"><li><a href="pages/btn_boxer/objects.html"><strong>2.1.</strong> Упаковки, кнопки и метки</a></li><li><a href="pages/btn_boxer/state.html"><strong>2.2.</strong> Сопровождение внешнего состояния</a></li><li><a href="pages/btn_boxer/ui.html"><strong>2.3.</strong> Создание структуры UI</a></li><li><a href="pages/btn_boxer/programming.html"><strong>2.4.</strong> Программирование UI</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Gtk-Rust by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#gtk-rust-на-примерах" id="gtk-rust-на-примерах"><h1>Gtk-Rust на примерах</h1></a>
<p>Gtk-Rust by Example (GRBE) представляет собой неофициальную книгу по разработке GTK GUI, на <a href="https://www.rust-lang.org/ru-RU/">языке программирования Rust</a>, которая будет демонстрировать практическое использование <a href="https://github.com/gtk-rs/gtk/">библиотеки GTK</a> на различных примерах.</p>
<p>Перед тем как начать, укажите версию библиотеки в вашем <code>Cargo.toml</code> файле:</p>
<pre><code>[dependencies.gtk]
version = &quot;0.3.0&quot;
features = [&quot;v3_22&quot;]
</code></pre>
<a class="header" href="print.html#Окно-с-панелью-заголовка" id="Окно-с-панелью-заголовка"><h1>Окно с панелью заголовка</h1></a>
<p><img src="img/hello_world.png" /></p>
<blockquote>
<p>Исходный код программы для этой главы можно найти <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/hello_world">здесь</a>.</p>
</blockquote>
<p>В этой главе мы создадим простое GTK приложение с панелью заголовка. Этот пример познакомит Вас с основами создания структуры приложения, которое будет содержать виджет и окно с заголовком.</p>
<a class="header" href="print.html#Создание-структуры-приложения" id="Создание-структуры-приложения"><h2>Создание структуры приложения</h2></a>
<p>Следующая диаграмма показывает, как мы будет проектировать структуру для нашего GTK приложения.
Можно и не следовать этой диаграмме для достижения главного результата, однако, проектирование структуры пользовательского интерфейса может быть полезной пищей для ума.</p>
<p><img src="img/diagram.png" /></p>
<p>В примере ниже, мы создадим структуру с <strong>GtkWindow</strong> и <strong>Header</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate gtk;

use gtk::*;

// Объявим структуру `Application`.
pub struct Application {
    pub window: Window,
    pub header: Header,
}
#}</code></pre></pre>
<p><strong>Header</strong> - это еще одна структура, которая будет содержать <strong>GtkHeaderbar</strong> и все виджеты внутри этой панели заголовка.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Объявим структуру `Header`.
pub struct Header {
    pub container: HeaderBar,
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-пользовательского-интерфейса-ui" id="Создание-пользовательского-интерфейса-ui"><h2>Создание пользовательского интерфейса (UI)</h2></a>
<p>Далее, мы создадим интерфейс с помощью Rust и расположим его в &quot;ново-объявленных&quot; структурах.</p>
<p>Во-первых, структура нашего приложения будет содержать в себе все другие структуры нашего пользовательского интерфейса. В примере ниже находится код с комментариями, описывающие каждый метод, который мы будем использовать для конфигурации.</p>
<p>Мы создадим <strong>GtkWindow</strong> и &quot;присоединим&quot; каждый элемент UI. Структура <code>Header</code> будет распологать в себе другие <strong>GtkHeaderBar</strong>. Далее, напишем функцию для выхода из приложения.
Важно также установить описание для окна и <code>wmclass</code>, который будет отображаться оконными менеджерами, а с помощью функции <code>Window::set_default_icon_name()</code> настроим отображаемую иконку.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Блок реализации.
impl Application {
    fn new() -&gt; Application {
        // Создадим новое окно с типом `Toplevel`.
        let window = Window::new(WindowType::Toplevel);
        // Создадим панель заголовка и связанный с ним контент.
        let header = Header::new();

        // Укажем название заголовка виджета.
        window.set_titlebar(&amp;header.container);
        // Укажем название для окна приложения.
        window.set_title(&quot;Простая программа&quot;);
        // Установим класс для оконного менеджера.
        window.set_wmclass(&quot;simple-gtk&quot;, &quot;Простая программа&quot;);
        // Установим иконку, отображаемую приложением.
        Window::set_default_icon_name(&quot;имя_иконки&quot;);

        // Программа закроется, если нажата кнопка выхода.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Возвращаем основное состояние приложения.
        Application { window, header }
    }
}
#}</code></pre></pre>
<p>Здесь распологается блок реализации для структуры <strong>Header</strong>, которая на данный момент содержит только <strong>GtkHeaderBar</strong>. Важно указать описание для этой панели заголовка, чтобы она отображалась, а также сделать активными элементы управления окном, поскольку они отключены по-умолчанию.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создадим виджет контейнера для главной панели заголовка.
        let container = HeaderBar::new();
        // Установим отображаемый тект в секции для названия.
        container.set_title(&quot;Simple GTK&quot;);
        // Делаем активными элементы управления окна в этой панели.
        container.set_show_close_button(true);

        // Возвращаем заголовок и его состояние.
        Header { container }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Инициализация-и-запуск-приложения" id="Инициализация-и-запуск-приложения"><h2>Инициализация и запуск приложения</h2></a>
<p>Теперь, когда мы готовы, нам нужно просто инициализировать GTK, создать структуру приложения, показать все виджеты внутри этой структуры и запустить главный цикл событий GTK.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Инициализация GTK.
    if gtk::init().is_err() {
        eprintln!(&quot;Не удалось инициализировать GTK приложение.&quot;);
        return;
    }

    // Инициализация начального состояния UI.
    let app = Application::new();

    // Делаем видимыми все виджеты с UI.
    app.window.show_all();

    // Запуск основного цикла GTK.
    gtk::main();
}
</code></pre></pre>
<p>После того, как основной поток вошёл в цикл событий, он будет взаимодействовать с каждым вызваным виджетом для действий, например: метод <code>connect_delete_event()</code>, который мы использовали выше, чтобы запрограммировать кнопку выхода для закрытия программы.</p>
<a class="header" href="print.html#Результат" id="Результат"><h2>Результат</h2></a>
<p>После того, как вы написали код, соберите и запустите программу, которая выглядит вот так:</p>
<pre><code class="language-bash">cargo build &amp;&amp; cargo run
</code></pre>
<p><img src="img/hello_world.png" /></p>
<a class="header" href="print.html#Боксирующие-кнопки" id="Боксирующие-кнопки"><h1>Боксирующие кнопки</h1></a>
<p><img src="img/btn_boxer.png" /></p>
<blockquote>
<p>Исходный код программы для этой главы можно найти <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/button_boxer">здесь</a>.</p>
</blockquote>
<p>В этом разделе мы рассмотрим, как структурировать Ваш UI с помощью <code>коробок</code>(box), изменять <code>метку</code>(label) и запрограммировать нажатие по кнопке. А также, к концу вы поймёте, как:</p>
<ol>
<li>Добавлять дочерние элементы в панель заголовка;</li>
<li>Добавлять классы стилей к кнопке;</li>
<li>Управлять состоянием приложения с помощью атомарных счётчиков <strong>Arc</strong> и выравнивать виджеты внутри контейнера.</li>
</ol>
<blockquote>
<p>Напомним, что каждый GTK объект, который можно получить из контейнера <strong>gtk</strong> - заворачивают,
так что не стоит беспокоится о правилах заимствования Rust. Объекты GTK считают ссылки,
поэтому, когда вам нужно передать GTK объект через несколько замыканий, вы можете
сделать это с помощью клонирования новой ссылки.</p>
</blockquote>
<a class="header" href="print.html#Необходимые-знания" id="Необходимые-знания"><h2>Необходимые знания</h2></a>
<p>Прежде чем продолжить изучение урока, убедитесь что вы понимаете что такое атомарность и атомарный счётчик ссылок (<strong>Arc</strong>). Эти понятия критически важны для возможности разделять состояние между несколькими замыканиями или потоками.
Изучить этот вопрос можно в документации модулей <code>std::sync</code> и <code>std::sync::atomic</code>. Так же, вы можете ознакомиться с безблокировочной конкурентностью (lockless concurrency) <a href="https://assets.bitbashing.io/papers/lockless.pdf">в этом документе</a>.</p>
<a class="header" href="print.html#Упаковки-кнопки-и-метки" id="Упаковки-кнопки-и-метки"><h1>Упаковки, кнопки и метки</h1></a>
<p>Цель этого раздела заключается в том, чтобы дать объяснение объектам, которые будут использованы до того, как мы применим их на практике в следующих разделах.</p>
<a class="header" href="print.html#gtkbox" id="gtkbox"><h2>GtkBox</h2></a>
<p><strong>GtkBox</strong> является фактически эквивалентом UI вектора в Rust и должена быть объявлена с помощью <strong>Orientation</strong>, который определяет, что должны ли элементы быть выровнены слева направо или сверху вниз. Для тех, кто имеет опыт разработки с современным дизайном HTML5/CSS3, <strong>GtkBox</strong> эквивалентен гибким упаковкам -- они могут расширяться на всё пространство, а виджеты, содержащиеся внутри, тоже могут расширяться в соответствии с правилами, применяемыми при дочерней упаковке.</p>
<a class="header" href="print.html#Создание-упаковки" id="Создание-упаковки"><h2>Создание упаковки</h2></a>
<p>В следующем примере, мы создадим горизонтальную и вертикальную упаковку с нулевым отступом между дочерними элементами, содержащимися в упаковке. После создания упаковки, вы можете задать виджеты, ипсользуя метод <code>pack_*</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let padding_between_children = 0;
let horizontal_box = Box::new(Orientation::Horizontal, padding_between_children);
let vertical_box = Box::new(Orientation::Vertical, padding_between_children);
#}</code></pre></pre>
<a class="header" href="print.html#Упаковка-упаковки" id="Упаковка-упаковки"><h2>Упаковка упаковки</h2></a>
<p>Вы могли заметить, что метод <code>pack_*</code> принимает большое количество параметров. Первым параметром должна быть ссылка на виджет, которую вы добавляете в контейнер. Вторым и третьим параметрами объявляют параметры заполнения соответственно. Последним параметром объявляют - как много единиц пространства должно быть между дочерними элементами в упаковке.</p>
<blockquote>
<p>To further elaborate on the expand and fill parameters, expand defines whether the
given widget should attempt to use all of the extra space that it can. Each widget that has
the expand parameter set will equally share that extra space. Meanwhile, fill defines whether
the extra spaced should actually have that widget fill to cover that extra space, or should
merely use that extra space as padding.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
health_info.pack_start(&amp;health_label, false, false, 5);
health_info.pack_start(&amp;health, true, true, 5);
#}</code></pre></pre>
<a class="header" href="print.html#gtklabel" id="gtklabel"><h2>GtkLabel</h2></a>
<p><strong>GtkLabel</strong> - это простой виджет, который состоит исключительно из текста. Название говорит само за себя. Всё, что вам нужно запомнить - это как создать метку(label) и изменить её.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let information_label = Label::new(&quot;Specific Information: &quot;);
let value = Label::new(&quot;Linux&quot;);
value.set_label(&quot;Redox&quot;);

let horizontal_box = Box::new(Orientation::Horizontal, 5);
horizontal_box.pack_start(&amp;information_label, false, false, 0);
horizontal_box.pack_start(&amp;value, true, false, 0);
#}</code></pre></pre>
<a class="header" href="print.html#gtkbutton" id="gtkbutton"><h2>GtkButton</h2></a>
<a class="header" href="print.html#Создание-кнопок" id="Создание-кнопок"><h3>Создание кнопок</h3></a>
<p><strong>GtkButton</strong> - это простая кнопка, содержащая текстовую метку(label) и/или изображения для представления действия, которое должно быть выполнено при нажатии кнопки.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let text_button = Button::new_with_label(&quot;Ok&quot;);
let image_button = Button::new_from_icon_name(&quot;имя-иконки&quot;, 32);
#}</code></pre></pre>
<a class="header" href="print.html#Дизайн-кнопок" id="Дизайн-кнопок"><h3>Дизайн кнопок</h3></a>
<p>Виджеты в GTK можно оформить так, чтобы они отличались от других виджетов в пользовательском интерфейсе(UI). В частности, кнопки поддерживают два класса стилей: destructive-action, and suggested-action. Если в вашем UI есть особенная кнопка, которая должна отличаться, вы можете установить её так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Добавьте соответствующие классы стилей к этим кнопкам.
delete_button.get_style_context().map(|c| c.add_class(&quot;destructive-action&quot;));
new_button.get_style_context().map(|c| c.add_class(&quot;suggested-action&quot;));
#}</code></pre></pre>
<p>Каждый <strong>GtkWidget</strong> предоставляет метод <strong>get_style_context()</strong>, который возвращает
<strong>Option<StyleContext></strong>, тем самым предоставляя метод <strong>add_class()</strong>, который используется чтобы установить класс стиля. Понимаете это? Хорошо. Наиболее важные классы кнопок, которые нужно знать - это <code>destructive-action</code> и <code>suggested-action</code>. Как правило, destructive action окрашивает кнопку в красный цвет, между тем, suggested action использует синий цвет. Актуальный цвет будет зависеть от того, какая тема GTK используется вами.</p>
<a class="header" href="print.html#Сопровождение-внешнего-состояния" id="Сопровождение-внешнего-состояния"><h1>Сопровождение внешнего состояния</h1></a>
<p>В этой главе у нас будет некоторое состояние, которым мы будем управлять с помощью UI. Поэтому нам необходим способ хранения и загрузки значения из этого состояния. Программа, которую мы хотим написать, имеет один компонент: значение здоровья.</p>
<p>Как оказалось, мы напрямую можем воспользоваться атомарными примитивами, таким как <strong>AtomicUsize</strong>, чтобы хранить значение для совместного использования нескольких неизменяемых замыканий. Этим атомарным значением можно управлять, не требуя изменяемого доступа к внутреннему значению. Таким образом, мы можем передавать неизменяемые ссылки на это значение и изменять его даже когда оно уже одолжено в нескольких местах одновременно.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct HealthComponent(AtomicUsize);
#}</code></pre></pre>
<p>Пока мы здесь, можем продолжить и написать некоторую логику для этой структуры в блоке реализации, используя следующие методы для здоровья:<code>initializing</code>,<code>subtracting</code> и <code>healing</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl HealthComponent {
    fn new(initial: usize) -&gt; HealthComponent { HealthComponent(AtomicUsize::new(initial)) }

    fn get_health(&amp;self) -&gt; usize { self.0.load(Ordering::SeqCst) }

    fn subtract(&amp;self, value: usize) -&gt; usize {
        let current = self.0.load(Ordering::SeqCst);
        let new = if current &lt; value { 0 } else { current - value };
        self.0.store(new, Ordering::SeqCst);
        new
    }

    fn heal(&amp;self, value: usize) -&gt; usize {
        let original = self.0.fetch_add(value, Ordering::SeqCst);
        original + value
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-структуры-пользовательского-интерфейса-ui" id="Создание-структуры-пользовательского-интерфейса-ui"><h1>Создание структуры пользовательского интерфейса (UI)</h1></a>
<p>Используя структуру предыдущей главы в качестве образца, мы можем расширить её, чтобы включить новые элементы UI, которые будем использовать в нашей программе. It is important to note that you only need to store elements that you are going to later program after the UI is constructed.</p>
<p>В этой программе мы добавим два <strong>GtkButtons</strong> к панели заголовка и воспользуемся вертикальной и горизонтальной <strong>GtkBox</strong> с некоторыми метками (labels), чтобы отобразить информацию о текущем состоянии нашего приложения. Следующее изображение является нашей новой диаграммой структур.</p>
<p><img src="img/btn_diagram.png" /></p>
<p>Что означает следующее в Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window:  Window,
    pub header:  Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub hit:       Button,
    pub heal:      Button,
}

pub struct Content {
    pub container: Box,
    pub health:    Label,
    pub message:   Label,
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-структуры-app" id="Создание-структуры-app"><h2>Создание структуры App</h2></a>
<p>Следуя последнему уроку, начнём с нашей структуры <strong>App</strong>. Метод <strong>new()</strong> должен принимать ссылку на <strong>&amp;HealthComponent</strong> в качестве вводимого значения в UI, later on
down the road within our <strong>Content</strong> structure. One will note that we have added a new
<strong>content</strong> variable of type <strong>Context</strong>, which takes that health reference.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl App {
    fn new(health: &amp;HealthComponent) -&gt; App {
        // Создадим новое окно с типом `Toplevel`.
        let window = Window::new(WindowType::Toplevel);
        // Создадим заголовок и связанное с ним содержимое.
        let header = Header::new();
        // Расположим содержимое в окне.
        let content = Content::new(health);

        // Set the headerbar as the title bar widget.
        window.set_titlebar(&amp;header.container);
        // Установим описание для окна.
        window.set_title(&quot;Боксирующие кнопки&quot;);
        // Установим класс для оконного менеджера.
        window.set_wmclass(&quot;app-name&quot;, &quot;Боксирующие кнопки&quot;);
        // Установим иконку, отображаемую приложением.
        Window::set_default_icon_name(&quot;имя-иконки&quot;);
        // Добавим коробку с содержимым в окно.
        window.add(&amp;content.container);

        // Запрограммируем выход из программы при нажатии кнопки.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Вернём состояние нашего приложения.
        App {
            window,
            header,
            content,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-header" id="Создание-header"><h2>Создание Header</h2></a>
<p>Затем мы так же реализуем метод для нашего заголовка, который должен содержать два элемента <strong>GtkButtons</strong> -- кнопка удара и лечения. Также обратите внимание, что мы устанавливаем некоторые классы стилей этим кнопкам, чтобы дать им более информативную визуальную способность.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создадим главный заголовочный бар содержащий виджет.
        let container = HeaderBar::new();

        // Установим текст для отображения в секции для названия.
        container.set_title(&quot;Боксирующие кнопки&quot;);
        // Сделаем активными элементы управления окна в этой панели.
        container.set_show_close_button(true);

        // Создадим кнопки: `ударить` и `лечить`.
        let hit = Button::new_with_label(&quot;Ударить&quot;);
        let heal = Button::new_with_label(&quot;Лечить&quot;);

        // Добавим соответствующие классы стилей к этим кнопкам.
        hit.get_style_context()
            .map(|c| c.add_class(&quot;destructive-action&quot;));
        heal.get_style_context()
            .map(|c| c.add_class(&quot;suggested-action&quot;));

        // Теперь добавим их в панель заголовка.
        container.pack_start(&amp;hit);
        container.pack_end(&amp;heal);

        // Вернём the header and all of it's state
        Header {
            container,
            hit,
            heal,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-content" id="Создание-content"><h2>Создание Content</h2></a>
<p>Теперь пришло время создать содержимое для нашего окна. При создании своего интерфейса (UI) с древовидной диаграммой, вы почти достигните <strong>GtkBoxes</strong>. При инициализации, эта упаковка должна быть указана с <strong>Horizontal</strong> или  <strong>Vertical</strong> оринтацией.</p>
<p>You will amost certainly reach for <strong>GtkBoxes</strong> for configuring your UI. These can be created with either a <strong>Horizontal</strong> or <strong>Vertical</strong> alignment. These boxes are where you will add all of your widgets, where they will be stacked according to the alignment of the box they are attached to.</p>
<p>Мы должны создать вертикальную упаковку, которая содержит два дочерних элемента: вертикальный <strong>GtkBox</strong> содержащий метку (label) и значение, а затем ниже простой <strong>GtkLabel</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new(health: &amp;HealthComponent) -&gt; Content {
        // Создадим вертикальную упаковку, чтобы хранить там все дочерние элементы.
        let container = Box::new(Orientation::Vertical, 0);

        // Информация о здоровье будет храниться в горизонтальной упаковке вместе с вертикальной.
        let health_info = Box::new(Orientation::Horizontal, 0);
        let health_label = Label::new(&quot;Текущее значение здоровья:&quot;);
        let health = Label::new(health.get_health().to_string().as_str());

        // Установим горизонтальное выравнивание для наших объектов.
        health_info.set_halign(Align::Center);
        health_label.set_halign(Align::Start);
        health.set_halign(Align::Start);

        // Добивим информацию о здоровье в дочернюю коробку.
        health_info.pack_start(&amp;health_label, false, false, 5);
        health_info.pack_start(&amp;health, true, true, 5);

        /*
         *   Создадим метку, которая будет изменяться приложением
         *   при выполнении удара или лечения.
         */
        let message = Label::new(&quot;Привет&quot;);

        // Добавим все в нашу вертикальную коробку.
        container.pack_start(&amp;health_info, true, false, 0);
        container.pack_start(&amp;Separator::new(Orientation::Horizontal), false, false, 0);
        container.pack_start(&amp;message, true, false, 0);

        Content {
            container,
            health,
            message,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Устанавливаем-выравнивание" id="Устанавливаем-выравнивание"><h3>Устанавливаем выравнивание</h3></a>
<p>Возможно, вы заметили, что приведённый код выше устанавливает горизонтальные выравнивания.
По желанию, с помощью методов <code>set_halign()</code> и <code>set_valign()</code>, можно установить выравнивание для виджетов.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Установим горизонтальное выравнивание для наших объектов.
health_info.set_halign(Align::Center);
health_label.set_halign(Align::Start);
health.set_halign(Align::Start);
#}</code></pre></pre>
<a class="header" href="print.html#programming-the-ui" id="programming-the-ui"><h1>Programming the UI</h1></a>
<p>На этом этапе, мы сможем соединить всё вместе. Сначала мы установим стандартное значение здоровья для программы. Это значение будет использоваться для инициализации состояния структуры приложения. Затем, мы напишем код для кнопки удара и лечения, которые будут должны изменять значение содержимого в главном окне.</p>
<a class="header" href="print.html#Перед-тем-как-мы-начнём" id="Перед-тем-как-мы-начнём"><h2>Перед тем, как мы начнём</h2></a>
<p>В нашем распоряжении будет несколько строк, которые будут использованы взависимости от действия. Это массив <strong>MESSAGES</strong>, к которому мы будем обращатся с помощью типажа с типом <strong>u8</strong>, который будет использован для получения индексов в массиве.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Заданные сообщения, которые будут использоваться в UI
// при определённых условиях.
const MESSAGES: [&amp;str; 3] = [&quot;Ой! Ты ударил меня!&quot;, &quot;...&quot;, &quot;Спасибо!&quot;];

#[repr(u8)]
// Типаж с типом `u8`, который используется как индекс в массиве `MESSAGES`.
enum Message { Hit, Dead, Heal }
#}</code></pre></pre>
<p>Для тех, кто плохо разбирается в Rust, атрибут <code>#[repr(u8)]</code> определяет, что следующие элементы будут представлены типом <strong>u8</strong> в памяти. По умолчанию, варианты для типажей начинаются с нуля, поэтому <strong>Hit</strong> это <code>0</code>, тогда как <strong>Heal</strong> это <code>2</code>. Если вы хотите сделать это явным, вы можете написать это как:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
enum Message { Hit = 0, Dead = 1, Heal = 2 }
#}</code></pre></pre>
<a class="header" href="print.html#Инициализация-компонента-health-и-структурирование-приложения" id="Инициализация-компонента-health-и-структурирование-приложения"><h2>Инициализация компонента Health и структурирование приложения</h2></a>
<p>После инициализации GTK, мы можем создать наш компонент <code>health</code>, который будет обёрнут внутри атомарного счётчика (<strong>Arc</strong>). Если вы запомнили предыдущий код, то на самом деле внутреннее значение это <strong>AtomicUsize</strong>, который служит нашим счетчиком <code>health</code>. Это значение будет передаваться через несколько замыканий, следовательно требуется для счётчика ссылок.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let health = Arc::new(HealthComponent::new(10));
#}</code></pre></pre>
<p>Используя это значение, мы создадим структуру UI нашего приложения. Обратите внимание, что <code>&amp;health</code> автоматически ссылается как <strong>&amp;HealthComponent</strong>, даже если завёрнут в <strong>Arc</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = App::new(&amp;health);
#}</code></pre></pre>
<a class="header" href="print.html#Запрограммируем-кнопку-удара" id="Запрограммируем-кнопку-удара"><h2>Запрограммируем кнопку удара</h2></a>
<p>Находясь здесь, всё что нам надо - это написать код наших виджетов. Именно здесь мы будем передавать оба компонента <code>health</code> и другие различные виджеты UI через замыкания. Начнём с кнопки лечения. Нам просто нужно сказать программе: &quot;Что произойдет при нажатии на кнопку&quot; ?
Типаж <strong>ButtonExt</strong> предоставляет метод <strong>connect_clicked()</strong> именно для этого.</p>
<blockquote>
<p>Обратите внимание, что виджеты в GTK обычно проходят через их замыкания, поэтому, если
вы хотите управлять вызовом виджета, вы можете сделать это используя выбранное значение
через замыкание. Мы не нуждаемся в этой функциональности, поэтому просто проигнорируем
зачение.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
widget.connect_action(move |widget| {});
#}</code></pre></pre>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Запрограммируем кнопку `Ударить` чтобы уменьшить здоровье.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.hit.clone().connect_clicked(move |_| {
        let new_health = health.subtract(1);
        let action = if new_health == 0 { Message::Dead } else { Message::Hit };
        message.set_label(MESSAGES[action as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}
#}</code></pre></pre>
<p>В коде выше, мы создали анонимную область, чтобы мы могли содержать наши клонированные ссылки.
Каждый вызов <strong>clone()</strong> просто увеличивает счётчик ссылок и делает значние доступным,
чтобы использовать его еще раз позже.</p>
<p>После вычитания из компонента health, если health равен <code>0</code>, то мы должны вернуть <strong>Message::Dead</strong>, иначе, сообщением будет <strong>MessageHit</strong>. После того, как мы овладели этой информацией, это просто вопрос обновления метки с новым значением.</p>
<a class="header" href="print.html#Запрограммируем-кнопку-лечения" id="Запрограммируем-кнопку-лечения"><h2>Запрограммируем кнопку лечения</h2></a>
<p>Это работает почти также, поэтому мы можем скопировать и вставить код выше, а затем изменить его, чтобы удовлетворить наши потребности.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Запрограммируем кнопку `Лечить`, чтобы вернуть очки здоровья.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.heal.clone().connect_clicked(move |_| {
        let new_health = health.heal(5);
        message.set_label(MESSAGES[Message::Heal as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}
#}</code></pre></pre>
<a class="header" href="print.html#В-общей-сложности" id="В-общей-сложности"><h2>В общей сложности</h2></a>
<p>После программирования UI, вы можете завершить код, выполнив следующее:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Сделаем все виджеты видимыми в UI.
app.window.show_all();

// Запуск основного цикла GTK.
gtk::main();
#}</code></pre></pre>
<p>Ваш исходный код должен быть таким:</p>
<pre><pre class="playpen"><code class="language-rust">// Заданные сообщения, которые будут использоваться в UI
// при определённых условиях.
const MESSAGES: [&amp;str; 3] = [&quot;Ouch! You hit me!&quot;, &quot;...&quot;, &quot;Thanks!&quot;];

#[repr(u8)]
// Типаж с типом `u8`, который используется как индекс в массиве `MESSAGES`.
enum Message { Hit, Dead, Heal }

fn main() {
    // Инициализируем GTK перед продолжением.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    /*  Установим начальное состояние для нашего компонента - `health`.
     *   Воспользуемся `Arc`, для того, чтобы мы могли
     *   использовать несколько programmable замыканий.
     */
    let health = Arc::new(HealthComponent::new(10));

    // Инициализируем начальное состояние UI.
    let app = App::new(&amp;health);

    {
        // Запрограммируем кнопку `Ударить` чтобы уменьшить здоровье.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.hit.clone().connect_clicked(move |_| {
            let new_health = health.subtract(1);
            let action = if new_health == 0 { Message::Dead } else { Message::Hit };
            message.set_label(MESSAGES[action as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    {
        // Запрограммируем кнопку `Лечить`, чтобы вернуть очки здоровья.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.heal.clone().connect_clicked(move |_| {
            let new_health = health.heal(5);
            message.set_label(MESSAGES[Message::Heal as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    // Сделаем все виджеты видимыми в UI.
    app.window.show_all();

    // Запуск основного цикла GTK.
    gtk::main();
}
</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
