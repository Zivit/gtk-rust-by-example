<!DOCTYPE HTML>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>Gtk-Rust by Example</title>
        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="A description">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <base href="">

        <link rel="stylesheet" href="book.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <link rel="shortcut icon" href="favicon.png">

        <!-- Font Awesome -->
        <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme -->
        

        

        <!-- Fetch Clipboard.js from CDN but have a local fallback -->
        <script src="https://cdn.jsdelivr.net/clipboard.js/1.6.1/clipboard.min.js"></script>
        <script>
            if (typeof Clipboard == 'undefined') {
                document.write(unescape("%3Cscript src='clipboard.min.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch JQuery from CDN but have a local fallback -->
        <script src="https://code.jquery.com/jquery-2.1.4.min.js"></script>
        <script>
            if (typeof jQuery == 'undefined') {
                document.write(unescape("%3Cscript src='jquery.js'%3E%3C/script%3E"));
            }
        </script>

        <!-- Fetch store.js from local - TODO add CDN when 2.x.x is available on cdnjs -->
        <script src="store.js"></script>

    </head>
    <body class="light">
        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme = store.get('mdbook-theme');
            if (theme === null || theme === undefined) { theme = 'light'; }
            $('body').removeClass().addClass(theme);
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var sidebar = store.get('mdbook-sidebar');
            if (sidebar === "hidden") { $("html").addClass("sidebar-hidden") }
            else if (sidebar === "visible") { $("html").addClass("sidebar-visible") }
        </script>

        <div id="sidebar" class="sidebar">
            <ul class="chapter"><li><a href="pages/1/index.html"><strong>1.</strong> Введение</a></li><li><a href="pages/2/hello_world.html"><strong>2.</strong> Hello World</a></li><li><a href="pages/3/index.html"><strong>3.</strong> Боксирующие кнопки</a></li><li><ul class="section"><li><a href="pages/3/objects.html"><strong>3.1.</strong> Упаковки, кнопки и метки</a></li><li><a href="pages/3/state.html"><strong>3.2.</strong> Сопровождение внешнего состояния</a></li><li><a href="pages/3/ui.html"><strong>3.3.</strong> Создание структуры UI</a></li><li><a href="pages/3/programming.html"><strong>3.4.</strong> Программирование UI</a></li><li><a href="pages/3/review.html"><strong>3.5.</strong> Заключение и обзор</a></li></ul></li><li><a href="pages/4/index.html"><strong>4.</strong> Составитель статей из HTML</a></li><li><ul class="section"><li><a href="pages/4/entries.html"><strong>4.1.</strong> Поля, панели, прокручиваемые окна</a></li><li><a href="pages/4/horrorshow.html"><strong>4.2.</strong> HTML-шаблоны Horrorshow</a></li><li><a href="pages/4/structure.html"><strong>4.3.</strong> Создание структуры UI</a></li><li><a href="pages/4/programming.html"><strong>4.4.</strong> Программирование UI</a></li><li><a href="pages/4/concl.html"><strong>4.5.</strong> Заключение и обзор</a></li></ul></li><li><a href="pages/5/index.html"><strong>5.</strong> Простой редактор Common Mark</a></li><li><ul class="section"><li><a href="pages/5/source_views.html"><strong>5.1.</strong> Выбор файла, просмотр кода и web-страниц</a></li><li><a href="pages/5/setting_modules.html"><strong>5.2.</strong> Настройка модулей</a></li><li><a href="pages/5/ui_misc_rs.html"><strong>5.3.</strong> Модуль ui/misc.rs</a></li><li><a href="pages/5/creating_ui_structure.html"><strong>5.4.</strong> Создание структуры пользовательского интерфейса</a></li><li><a href="pages/5/external_state.html"><strong>5.5.</strong> Работа с внешним состоянием</a></li></ul></li></ul>
        </div>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page" tabindex="-1">
                
                <div id="menu-bar" class="menu-bar">
                    <div class="left-buttons">
                        <i id="sidebar-toggle" class="fa fa-bars" title="Toggle sidebar"></i>
                        <i id="theme-toggle" class="fa fa-paint-brush" title="Change theme"></i>
                    </div>

                    <h1 class="menu-title">Gtk-Rust by Example</h1>

                    <div class="right-buttons">
                        <a href="print.html">
                            <i id="print-button" class="fa fa-print" title="Print this book"></i>
                        </a>
                    </div>
                </div>

                <div id="content" class="content">
                    <a class="header" href="print.html#gtk-rust-на-примерах" id="gtk-rust-на-примерах"><h1>Gtk-Rust на примерах</h1></a>
<p>Gtk-Rust by Example (GRBE) представляет собой неофициальную книгу по разработке GTK GUI, на <a href="https://www.rust-lang.org/ru-RU/">языке программирования Rust</a>, которая будет демонстрировать практическое использование <a href="https://github.com/gtk-rs/gtk/">библиотеки GTK</a> на различных примерах.</p>
<p>Перед тем как начать, укажите версию библиотеки в вашем <code>Cargo.toml</code> файле:</p>
<pre><code>[dependencies.gtk]
version = &quot;0.3.0&quot;
features = [&quot;v3_22&quot;]
</code></pre>
<a class="header" href="print.html#Окно-с-панелью-заголовка" id="Окно-с-панелью-заголовка"><h1>Окно с панелью заголовка</h1></a>
<p><img src="img/2/hello_world.png" /></p>
<blockquote>
<p>Исходный код программы для этой главы можно найти <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/hello_world">здесь</a>.</p>
</blockquote>
<p>В этой главе мы создадим простое GTK приложение с панелью заголовка. Этот пример познакомит Вас с основами создания структуры приложения, которое будет содержать виджет и окно с заголовком.</p>
<a class="header" href="print.html#Создание-структуры-приложения" id="Создание-структуры-приложения"><h2>Создание структуры приложения</h2></a>
<p>Следующая диаграмма показывает, как мы будет проектировать структуру для нашего GTK приложения.
Можно и не следовать этой диаграмме для достижения главного результата, однако, проектирование структуры пользовательского интерфейса может быть полезной пищей для ума.</p>
<p><img src="img/2/diagram.png" /></p>
<p>В примере ниже, мы создадим структуру с <strong>GtkWindow</strong> и <strong>Header</strong>:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
extern crate gtk;

use gtk::*;

// Объявим структуру `Application`.
pub struct Application {
    pub window: Window,
    pub header: Header,
}
#}</code></pre></pre>
<p><strong>Header</strong> - это еще одна структура, которая будет содержать <strong>GtkHeaderbar</strong> и все виджеты внутри этой панели заголовка.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Объявим структуру `Header`.
pub struct Header {
    pub container: HeaderBar,
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-пользовательского-интерфейса-ui" id="Создание-пользовательского-интерфейса-ui"><h2>Создание пользовательского интерфейса (UI)</h2></a>
<p>Далее, мы создадим интерфейс с помощью Rust и расположим его в &quot;ново-объявленных&quot; структурах.</p>
<p>Во-первых, структура нашего приложения будет содержать в себе все другие структуры нашего пользовательского интерфейса. В примере ниже находится код с комментариями, описывающие каждый метод, который мы будем использовать для конфигурации.</p>
<p>Мы создадим <strong>GtkWindow</strong> и &quot;присоединим&quot; каждый элемент UI. Структура <code>Header</code> будет распологать в себе другие <strong>GtkHeaderBar</strong>. Далее, напишем функцию для выхода из приложения.
Важно также установить описание для окна и <code>wmclass</code>, который будет отображаться оконными менеджерами, а с помощью функции <code>Window::set_default_icon_name()</code> настроим отображаемую иконку.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Блок реализации.
impl Application {
    fn new() -&gt; Application {
        // Создадим новое окно с типом `Toplevel`.
        let window = Window::new(WindowType::Toplevel);
        // Создадим панель заголовка и связанный с ним контент.
        let header = Header::new();

        // Укажем название заголовка виджета.
        window.set_titlebar(&amp;header.container);
        // Укажем название для окна приложения.
        window.set_title(&quot;Простая программа&quot;);
        // Установим класс для оконного менеджера.
        window.set_wmclass(&quot;simple-gtk&quot;, &quot;Простая программа&quot;);
        // Установим иконку, отображаемую приложением.
        Window::set_default_icon_name(&quot;имя_иконки&quot;);

        // Программа закроется, если нажата кнопка выхода.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Возвращаем основное состояние приложения.
        Application { window, header }
    }
}
#}</code></pre></pre>
<p>Здесь распологается блок реализации для структуры <strong>Header</strong>, которая на данный момент содержит только <strong>GtkHeaderBar</strong>. Важно указать описание для этой панели заголовка, чтобы она отображалась, а также сделать активными элементы управления окном, поскольку они отключены по-умолчанию.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создадим виджет контейнера для главной панели заголовка.
        let container = HeaderBar::new();
        // Установим отображаемый тект в секции для названия.
        container.set_title(&quot;Simple GTK&quot;);
        // Делаем активными элементы управления окна в этой панели.
        container.set_show_close_button(true);

        // Возвращаем заголовок и его состояние.
        Header { container }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Инициализация-и-запуск-приложения" id="Инициализация-и-запуск-приложения"><h2>Инициализация и запуск приложения</h2></a>
<p>Теперь, когда мы готовы, нам нужно просто инициализировать GTK, создать структуру приложения, показать все виджеты внутри этой структуры и запустить главный цикл событий GTK.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Инициализация GTK.
    if gtk::init().is_err() {
        eprintln!(&quot;Не удалось инициализировать GTK приложение.&quot;);
        return;
    }

    // Инициализация начального состояния UI.
    let app = Application::new();

    // Делаем видимыми все виджеты с UI.
    app.window.show_all();

    // Запуск основного цикла GTK.
    gtk::main();
}
</code></pre></pre>
<p>После того, как основной поток вошёл в цикл событий, он будет взаимодействовать с каждым вызваным виджетом для действий, например: метод <code>connect_delete_event()</code>, который мы использовали выше, чтобы запрограммировать кнопку выхода для закрытия программы.</p>
<a class="header" href="print.html#Результат" id="Результат"><h2>Результат</h2></a>
<p>После того, как вы написали код, соберите и запустите программу, которая выглядит вот так:</p>
<pre><code class="language-bash">cargo build &amp;&amp; cargo run
</code></pre>
<p><img src="img/2/hello_world.png" /></p>
<a class="header" href="print.html#Боксирующие-кнопки" id="Боксирующие-кнопки"><h1>Боксирующие кнопки</h1></a>
<p><img src="img/3/btn_boxer.png" /></p>
<blockquote>
<p>Исходный код программы для этой главы можно найти <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/button_boxer">здесь</a>.</p>
</blockquote>
<p>В этом разделе мы рассмотрим, как структурировать ваш UI с помощью <code>упаковок</code> (box), изменять <code>метку</code> (label) и запрограммировать нажатие по кнопке. А также, к концу вы поймёте, как:</p>
<ol>
<li>Добавлять дочерние элементы в панель заголовка;</li>
<li>Добавлять классы стилей к кнопке;</li>
<li>Управлять состоянием приложения с помощью атомарных счётчиков <strong>Arc</strong> и выравнивать виджеты внутри контейнера.</li>
</ol>
<blockquote>
<p>Напомним, что каждый GTK объект, который можно получить из контейнера <strong>gtk</strong> - заворачивают,
так что не стоит беспокоится о правилах заимствования Rust. Объекты GTK считают ссылки,
поэтому, когда вам нужно передать GTK объект через несколько замыканий, вы можете
сделать это с помощью клонирования новой ссылки.</p>
</blockquote>
<a class="header" href="print.html#Необходимые-знания" id="Необходимые-знания"><h2>Необходимые знания</h2></a>
<p>Прежде чем продолжить изучение урока, убедитесь что вы понимаете что такое атомарность и атомарный счётчик ссылок (<strong>Arc</strong>). Эти понятия критически важны для возможности разделять состояние между несколькими замыканиями или потоками.
Изучить этот вопрос можно в документации модулей <code>std::sync</code> и <code>std::sync::atomic</code>. Так же, вы можете ознакомиться с безблокировочной конкурентностью (lockless concurrency) <a href="https://assets.bitbashing.io/papers/lockless.pdf">в этом документе</a>.</p>
<a class="header" href="print.html#Упаковки-кнопки-и-метки" id="Упаковки-кнопки-и-метки"><h1>Упаковки, кнопки и метки</h1></a>
<p>Цель этого раздела заключается в том, чтобы дать объяснение объектам, которые будут использованы до того, как мы применим их на практике в следующих разделах.</p>
<a class="header" href="print.html#gtkbox" id="gtkbox"><h2>GtkBox</h2></a>
<p><strong>GtkBox</strong> является фактически эквивалентом UI вектора в Rust и должен быть объявлен с помощью <strong>Orientation</strong>, который определяет, что должны ли элементы быть выровнены слева направо или сверху вниз. Для тех, кто имеет опыт разработки с современным дизайном HTML5/CSS3, <strong>GtkBox</strong> эквивалентен гибким упаковкам -- они могут расширяться на всё пространство, а виджеты, содержащиеся внутри, тоже могут расширяться в соответствии с правилами, применяемыми при дочерней упаковке.</p>
<a class="header" href="print.html#Создание-упаковки" id="Создание-упаковки"><h2>Создание упаковки</h2></a>
<p>В следующем примере, мы создадим горизонтальную и вертикальную упаковку с нулевым отступом между дочерними элементами, содержащимися в упаковке. После создания упаковки, вы можете задать виджеты, ипсользуя метод <code>pack_*</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let padding_between_children = 0;
let horizontal_box = Box::new(Orientation::Horizontal, padding_between_children);
let vertical_box = Box::new(Orientation::Vertical, padding_between_children);
#}</code></pre></pre>
<a class="header" href="print.html#Упаковка-упаковки" id="Упаковка-упаковки"><h2>Упаковка упаковки</h2></a>
<p>Вы могли заметить, что метод <code>pack_*</code> принимает большое количество параметров. Первым параметром должна быть ссылка на виджет, которую вы добавляете в контейнер. Вторым и третьим параметрами объявляют параметры заполнения соответственно. Последним параметром объявляют - как много единиц пространства должно быть между дочерними элементами в упаковке.</p>
<blockquote>
<p>To further elaborate on the expand and fill parameters, expand defines whether the
given widget should attempt to use all of the extra space that it can. Each widget that has
the expand parameter set will equally share that extra space. Meanwhile, fill defines whether
the extra spaced should actually have that widget fill to cover that extra space, or should
merely use that extra space as padding.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
health_info.pack_start(&amp;health_label, false, false, 5);
health_info.pack_start(&amp;health, true, true, 5);
#}</code></pre></pre>
<a class="header" href="print.html#gtklabel" id="gtklabel"><h2>GtkLabel</h2></a>
<p><strong>GtkLabel</strong> - это простой виджет, который состоит исключительно из текста. Название говорит само за себя. Всё, что вам нужно запомнить - это как создать метку (label) и изменить её.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let information_label = Label::new(&quot;Specific Information: &quot;);
let value = Label::new(&quot;Linux&quot;);
value.set_label(&quot;Redox&quot;);

let horizontal_box = Box::new(Orientation::Horizontal, 5);
horizontal_box.pack_start(&amp;information_label, false, false, 0);
horizontal_box.pack_start(&amp;value, true, false, 0);
#}</code></pre></pre>
<a class="header" href="print.html#gtkbutton" id="gtkbutton"><h2>GtkButton</h2></a>
<a class="header" href="print.html#Создание-кнопок" id="Создание-кнопок"><h3>Создание кнопок</h3></a>
<p><strong>GtkButton</strong> - это простая кнопка, содержащая текстовую метку (label) и/или изображения для представления действия, которое должно быть выполнено при нажатии кнопки.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let text_button = Button::new_with_label(&quot;Ok&quot;);
let image_button = Button::new_from_icon_name(&quot;имя-иконки&quot;, 32);
#}</code></pre></pre>
<a class="header" href="print.html#Дизайн-кнопок" id="Дизайн-кнопок"><h3>Дизайн кнопок</h3></a>
<p>Виджеты в GTK можно оформить так, чтобы они отличались от других виджетов в пользовательском интерфейсе (UI). В частности, кнопки поддерживают два класса стилей: destructive-action и suggested-action. Если в вашем UI есть особенная кнопка, которая должна отличаться, вы можете установить её так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Добавьте соответствующие классы стилей к этим кнопкам.
delete_button.get_style_context().map(|c| c.add_class(&quot;destructive-action&quot;));
new_button.get_style_context().map(|c| c.add_class(&quot;suggested-action&quot;));
#}</code></pre></pre>
<p>Каждый <strong>GtkWidget</strong> предоставляет метод <strong>get_style_context()</strong>, который возвращает
<strong>Option<StyleContext></strong>, тем самым предоставляя метод <strong>add_class()</strong>, который используется чтобы установить класс стиля. Понимаете это? Хорошо. Наиболее важные классы кнопок, которые нужно знать - это <code>destructive-action</code> и <code>suggested-action</code>. Как правило, destructive action окрашивает кнопку в красный цвет, между тем, suggested action использует синий цвет. Актуальный цвет будет зависеть от того, какая тема GTK используется вами.</p>
<a class="header" href="print.html#Сопровождение-внешнего-состояния" id="Сопровождение-внешнего-состояния"><h1>Сопровождение внешнего состояния</h1></a>
<p>В этой главе у нас будет некоторое состояние, которым мы будем управлять с помощью UI. Поэтому нам необходим способ хранения и загрузки значения из этого состояния. Программа, которую мы хотим написать, имеет один компонент: значение здоровья.</p>
<p>Как оказалось, мы напрямую можем воспользоваться атомарными примитивами, таким как <strong>AtomicUsize</strong>, чтобы хранить значение для совместного использования нескольких неизменяемых замыканий. Этим атомарным значением можно управлять, не требуя изменяемого доступа к внутреннему значению. Таким образом, мы можем передавать неизменяемые ссылки на это значение и изменять его даже когда оно уже одолжено в нескольких местах одновременно.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct HealthComponent(AtomicUsize);
#}</code></pre></pre>
<p>Пока мы здесь, можем продолжить и написать некоторую логику для этой структуры в блоке реализации, используя следующие методы для здоровья:<code>initializing</code>,<code>subtracting</code> и <code>healing</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl HealthComponent {
    fn new(initial: usize) -&gt; HealthComponent { HealthComponent(AtomicUsize::new(initial)) }

    fn get_health(&amp;self) -&gt; usize { self.0.load(Ordering::SeqCst) }

    fn subtract(&amp;self, value: usize) -&gt; usize {
        let current = self.0.load(Ordering::SeqCst);
        let new = if current &lt; value { 0 } else { current - value };
        self.0.store(new, Ordering::SeqCst);
        new
    }

    fn heal(&amp;self, value: usize) -&gt; usize {
        let original = self.0.fetch_add(value, Ordering::SeqCst);
        original + value
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-структуры-пользовательского-интерфейса-ui" id="Создание-структуры-пользовательского-интерфейса-ui"><h1>Создание структуры пользовательского интерфейса (UI)</h1></a>
<p>Используя структуру предыдущей главы в качестве образца, мы можем расширить её, чтобы включить новые элементы UI, которые будем использовать в нашей программе. Важно отметить, что необходимо хранить только те элементы, которые вы собираетесь запрограммировать позже, после создания структуры UI.</p>
<p>В этой программе мы добавим два виджета <strong>GtkButtons</strong> к панели заголовка и воспользуемся вертикальным и горизонтальным элементом <strong>GtkBox</strong> с некоторыми метками (labels), чтобы отобразить информацию о текущем состоянии нашего приложения. Следующее изображение является нашей новой диаграммой структур.</p>
<p><img src="img/3/btn_diagram.png" /></p>
<p>Что означает следующее в Rust:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window:  Window,
    pub header:  Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub hit:       Button,
    pub heal:      Button,
}

pub struct Content {
    pub container: Box,
    pub health:    Label,
    pub message:   Label,
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-структуры-app" id="Создание-структуры-app"><h2>Создание структуры App</h2></a>
<p>Следуя последнему уроку, начнём с нашей структуры <strong>App</strong>. Метод <strong>new()</strong> должен принимать ссылку на <strong>&amp;HealthComponent</strong> в качестве вводимого значения в UI. Заметим, что мы добавили новую переменную <strong>content</strong> типа <strong>Context</strong>, которая принимает эту ссылку на health.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl App {
    fn new(health: &amp;HealthComponent) -&gt; App {
        // Создадим новое окно с типом `Toplevel`.
        let window = Window::new(WindowType::Toplevel);
        // Создадим заголовок и связанное с ним содержимое.
        let header = Header::new();
        // Расположим содержимое в окне.
        let content = Content::new(health);

        // Установим панель заголовка как описание виджета.
        window.set_titlebar(&amp;header.container);
        // Установим описание для окна.
        window.set_title(&quot;Боксирующие кнопки&quot;);
        // Установим класс для оконного менеджера.
        window.set_wmclass(&quot;app-name&quot;, &quot;Боксирующие кнопки&quot;);
        // Установим иконку, отображаемую приложением.
        Window::set_default_icon_name(&quot;имя-иконки&quot;);
        // Добавим коробку с содержимым в окно.
        window.add(&amp;content.container);

        // Запрограммируем выход из программы при нажатии кнопки.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Вернём состояние нашего приложения.
        App {
            window,
            header,
            content,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-header" id="Создание-header"><h2>Создание Header</h2></a>
<p>Затем мы так же реализуем метод для нашего заголовка, который должен содержать два элемента <strong>GtkButtons</strong> -- кнопка удара и лечения. Также обратите внимание, что мы устанавливаем некоторые классы стилей этим кнопкам, чтобы дать им более информативную визуальную способность.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создадим главный заголовочный бар содержащий виджет.
        let container = HeaderBar::new();

        // Установим текст для отображения в секции для названия.
        container.set_title(&quot;Боксирующие кнопки&quot;);
        // Сделаем активными элементы управления окна в этой панели.
        container.set_show_close_button(true);

        // Создадим кнопки: `ударить` и `лечить`.
        let hit = Button::new_with_label(&quot;Ударить&quot;);
        let heal = Button::new_with_label(&quot;Лечить&quot;);

        // Добавим соответствующие классы стилей к этим кнопкам.
        hit.get_style_context()
            .map(|c| c.add_class(&quot;destructive-action&quot;));
        heal.get_style_context()
            .map(|c| c.add_class(&quot;suggested-action&quot;));

        // Теперь добавим их в панель заголовка.
        container.pack_start(&amp;hit);
        container.pack_end(&amp;heal);

        // Вернём the header and all of it's state
        Header {
            container,
            hit,
            heal,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-content" id="Создание-content"><h2>Создание Content</h2></a>
<p>Теперь пришло время создать содержимое для нашего окна. При создании своего интерфейса (UI) с древовидной диаграммой, вы почти достигните <strong>GtkBoxes</strong>. При инициализации, эта упаковка должна быть указана с <strong>Horizontal</strong> или  <strong>Vertical</strong> оринтацией.</p>
<p>Безусловно, вы достигните виджета <strong>GtkBoxes</strong> для настройки UI. Он может быть создан с <strong>Horizontal</strong> или <strong>Vertical</strong> выравниванием. В эти упаковки вы добавите все ваши виджеты, где они будут сложены в соответствии с выравниванием упаковки, к которой они присоединены.</p>
<p>Мы должны создать вертикальную упаковку, которая содержит два дочерних элемента: вертикальный виджет <strong>GtkBox</strong> содержащий метку и значение, а затем ниже простой виджет <strong>GtkLabel</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new(health: &amp;HealthComponent) -&gt; Content {
        // Создадим вертикальную упаковку, чтобы хранить там все дочерние элементы.
        let container = Box::new(Orientation::Vertical, 0);

        // Информация о здоровье будет храниться в горизонтальной упаковке вместе с вертикальной.
        let health_info = Box::new(Orientation::Horizontal, 0);
        let health_label = Label::new(&quot;Текущее значение здоровья:&quot;);
        let health = Label::new(health.get_health().to_string().as_str());

        // Установим горизонтальное выравнивание для наших объектов.
        health_info.set_halign(Align::Center);
        health_label.set_halign(Align::Start);
        health.set_halign(Align::Start);

        // Добивим информацию о здоровье в дочернюю коробку.
        health_info.pack_start(&amp;health_label, false, false, 5);
        health_info.pack_start(&amp;health, true, true, 5);

        /*
         *   Создадим метку, которая будет изменяться приложением
         *   при выполнении удара или лечения.
         */
        let message = Label::new(&quot;Привет&quot;);

        // Добавим все в нашу вертикальную коробку.
        container.pack_start(&amp;health_info, true, false, 0);
        container.pack_start(&amp;Separator::new(Orientation::Horizontal), false, false, 0);
        container.pack_start(&amp;message, true, false, 0);

        Content {
            container,
            health,
            message,
        }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Устанавливаем-выравнивание" id="Устанавливаем-выравнивание"><h3>Устанавливаем выравнивание</h3></a>
<p>Возможно, вы заметили, что приведённый код выше устанавливает горизонтальные выравнивания.
По желанию, с помощью методов <code>set_halign()</code> и <code>set_valign()</code>, можно установить выравнивание для виджетов.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Установим горизонтальное выравнивание для наших объектов.
health_info.set_halign(Align::Center);
health_label.set_halign(Align::Start);
health.set_halign(Align::Start);
#}</code></pre></pre>
<a class="header" href="print.html#Программирование-ui" id="Программирование-ui"><h1>Программирование UI</h1></a>
<p>На этом этапе, мы сможем соединить всё вместе. Сначала мы установим стандартное значение здоровья для программы. Это значение будет использоваться для инициализации состояния структуры приложения. Затем, мы напишем код для кнопки удара и лечения, которые будут должны изменять значение содержимого в главном окне.</p>
<a class="header" href="print.html#Перед-тем-как-мы-начнём" id="Перед-тем-как-мы-начнём"><h2>Перед тем, как мы начнём</h2></a>
<p>В нашем распоряжении будет несколько строк, которые будут использованы взависимости от действия. Это массив <strong>MESSAGES</strong>, к которому мы будем обращатся с помощью типажа с типом <strong>u8</strong>, который будет использован для получения индексов в массиве.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Заданные сообщения, которые будут использоваться в UI
// при определённых условиях.
const MESSAGES: [&amp;str; 3] = [&quot;Ой! Ты ударил меня!&quot;, &quot;...&quot;, &quot;Спасибо!&quot;];

#[repr(u8)]
// Типаж с типом `u8`, который используется как индекс в массиве `MESSAGES`.
enum Message { Hit, Dead, Heal }
#}</code></pre></pre>
<p>Для тех, кто плохо разбирается в Rust, атрибут <code>#[repr(u8)]</code> определяет, что следующие элементы будут представлены типом <strong>u8</strong> в памяти. По умолчанию, варианты для типажей начинаются с нуля, поэтому <strong>Hit</strong> это <code>0</code>, тогда как <strong>Heal</strong> это <code>2</code>. Если вы хотите сделать это явным, вы можете написать это как:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[repr(u8)]
enum Message { Hit = 0, Dead = 1, Heal = 2 }
#}</code></pre></pre>
<a class="header" href="print.html#Инициализация-компонента-health-и-структурирование-приложения" id="Инициализация-компонента-health-и-структурирование-приложения"><h2>Инициализация компонента Health и структурирование приложения</h2></a>
<p>После инициализации GTK, мы можем создать наш компонент <code>health</code>, который будет обёрнут внутри атомарного счётчика (<strong>Arc</strong>). Если вы запомнили предыдущий код, то на самом деле внутреннее значение это <strong>AtomicUsize</strong>, который служит нашим счетчиком <code>health</code>. Это значение будет передаваться через несколько замыканий, следовательно требуется для счётчика ссылок.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let health = Arc::new(HealthComponent::new(10));
#}</code></pre></pre>
<p>Используя это значение, мы создадим структуру UI нашего приложения. Обратите внимание, что <code>&amp;health</code> автоматически ссылается как <strong>&amp;HealthComponent</strong>, даже если завёрнут в <strong>Arc</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let app = App::new(&amp;health);
#}</code></pre></pre>
<a class="header" href="print.html#Запрограммируем-кнопку-удара" id="Запрограммируем-кнопку-удара"><h2>Запрограммируем кнопку удара</h2></a>
<p>Находясь здесь, всё что нам надо - это написать код наших виджетов. Именно здесь мы будем передавать оба компонента <code>health</code> и другие различные виджеты UI через замыкания. Начнём с кнопки лечения. Нам просто нужно сказать программе: &quot;Что произойдет при нажатии на кнопку&quot; ?
Типаж <strong>ButtonExt</strong> предоставляет метод <strong>connect_clicked()</strong> именно для этого.</p>
<blockquote>
<p>Обратите внимание, что виджеты в GTK обычно проходят через их замыкания, поэтому, если
вы хотите управлять вызовом виджета, вы можете сделать это используя выбранное значение
через замыкание. Мы не нуждаемся в этой функциональности, поэтому просто проигнорируем
зачение.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
widget.connect_action(move |widget| {});
#}</code></pre></pre>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Запрограммируем кнопку `Ударить` чтобы уменьшить здоровье.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.hit.clone().connect_clicked(move |_| {
        let new_health = health.subtract(1);
        let action = if new_health == 0 { Message::Dead } else { Message::Hit };
        message.set_label(MESSAGES[action as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}
#}</code></pre></pre>
<p>В коде выше, мы создали анонимную область, чтобы мы могли содержать наши клонированные ссылки.
Каждый вызов <strong>clone()</strong> просто увеличивает счётчик ссылок и делает значние доступным,
чтобы использовать его еще раз позже.</p>
<p>После вычитания из компонента health, если health равен <code>0</code>, то мы должны вернуть <strong>Message::Dead</strong>, иначе, сообщением будет <strong>MessageHit</strong>. После того, как мы овладели этой информацией, это просто вопрос обновления метки с новым значением.</p>
<a class="header" href="print.html#Запрограммируем-кнопку-лечения" id="Запрограммируем-кнопку-лечения"><h2>Запрограммируем кнопку лечения</h2></a>
<p>Это работает почти также, поэтому мы можем скопировать и вставить код выше, а затем изменить его, чтобы удовлетворить наши потребности.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Запрограммируем кнопку `Лечить`, чтобы вернуть очки здоровья.
    let health = health.clone();
    let message = app.content.message.clone();
    let info = app.content.health.clone();
    app.header.heal.clone().connect_clicked(move |_| {
        let new_health = health.heal(5);
        message.set_label(MESSAGES[Message::Heal as usize]);
        info.set_label(new_health.to_string().as_str());
    });
}
#}</code></pre></pre>
<a class="header" href="print.html#В-общей-сложности" id="В-общей-сложности"><h2>В общей сложности</h2></a>
<p>После программирования UI, вы можете завершить код, выполнив следующее:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Сделаем все виджеты видимыми в UI.
app.window.show_all();

// Запуск основного цикла GTK.
gtk::main();
#}</code></pre></pre>
<p>Ваш исходный код должен быть таким:</p>
<pre><pre class="playpen"><code class="language-rust">// Заданные сообщения, которые будут использоваться в UI
// при определённых условиях.
const MESSAGES: [&amp;str; 3] = [&quot;Ouch! You hit me!&quot;, &quot;...&quot;, &quot;Thanks!&quot;];

#[repr(u8)]
// Типаж с типом `u8`, который используется как индекс в массиве `MESSAGES`.
enum Message { Hit, Dead, Heal }

fn main() {
    // Инициализируем GTK перед продолжением.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    /*  Установим начальное состояние для нашего компонента - `health`.
     *   Воспользуемся `Arc`, для того, чтобы мы могли
     *   использовать несколько programmable замыканий.
     */
    let health = Arc::new(HealthComponent::new(10));

    // Инициализируем начальное состояние UI.
    let app = App::new(&amp;health);

    {
        // Запрограммируем кнопку `Ударить` чтобы уменьшить здоровье.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.hit.clone().connect_clicked(move |_| {
            let new_health = health.subtract(1);
            let action = if new_health == 0 { Message::Dead } else { Message::Hit };
            message.set_label(MESSAGES[action as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    {
        // Запрограммируем кнопку `Лечить`, чтобы вернуть очки здоровья.
        let health = health.clone();
        let message = app.content.message.clone();
        let info = app.content.health.clone();
        app.header.heal.clone().connect_clicked(move |_| {
            let new_health = health.heal(5);
            message.set_label(MESSAGES[Message::Heal as usize]);
            info.set_label(new_health.to_string().as_str());
        });
    }

    // Сделаем все виджеты видимыми в UI.
    app.window.show_all();

    // Запуск основного цикла GTK.
    gtk::main();
}
</code></pre></pre>
<a class="header" href="print.html#Заключение-и-обзор" id="Заключение-и-обзор"><h2>Заключение и обзор</h2></a>
<p>Если вы нажмёте на кнопку <code>Ударить</code>, счётчик должен уменьшиться и сообщение должно измениться. Нажатие по кнопке <code>Лечить</code> должно  увеличить счётчик и также изменить сообщение.После запуска вашей программы с помощью <code>cargo run</code>, вы должны увидеть окно, которое выглядит так:</p>
<p><img src="img/3/btn_boxer.png" /></p>
<p>На этом этапе, вы должны хорошо понимать как работают: <strong>GtkBox</strong>, <strong>GtkButton</strong> и <strong>GtkLabel</strong>. Вы можете вернуться к предыдущему разделу, чтобы ещё раз уточнить некоторые моменты.</p>
<a class="header" href="print.html#Практическое-занятие" id="Практическое-занятие"><h2>Практическое занятие</h2></a>
<a class="header" href="print.html#setting-inputs-w-buttons" id="setting-inputs-w-buttons"><h3>Setting Inputs w/ Buttons</h3></a>
<p>There isn't much that you can do with just buttons and labels. If you want a practice challenge, try creating a program that displays a simple random math problem, and asks the user to use buttons to set the value. If they get it correct, modify a label to tell the user that what they entered was correct. This is an incredibly annoying interface design, so don't do this in the real world!
Bonus: Timed Answers</p>
<p>Do the same as the above, but also take advantage of <code>gtk::timeout_add()</code> to decrement and update a timer label within the UI until the timer reaches zero.</p>
<a class="header" href="print.html#Составитель-статей-из-html" id="Составитель-статей-из-html"><h1>Составитель статей из HTML</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<blockquote>
<p>Исходный код для этой главы находится <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/html_article">здесь</a>.</p>
</blockquote>
<p>В данной главе вы начнете писать полезные программы, используя поля для ввода
и просмотра текста, для того чтобы дать возможность пользователю вводить нужные
значения в текстовые поля и генерировать выходные значения из введенных
значений после нажатия на кнопку. В добавок вы познакомитесь с
макроопределением <code>html!</code>, который находится внутри пакета <em>horrorshow</em>. Вы
будете писать программу, которая принимает введенные значения на левой панели
и генерирует HTML на правом поле для просмотра текста.</p>
<blockquote>
<p>Обратите внимание на то что, что в данной главе мы не рассматриваем вопрос
хранения данных во внешнем источнике, как это было в прошлой главе. Все состояние,
которое нас интересует, находится внутри GTK объектов, с которыми мы будем
взаимодействовать.</p>
</blockquote>
<a class="header" href="print.html#Поля-панели-прокручиваемые-окна-и-просмотр-текста" id="Поля-панели-прокручиваемые-окна-и-просмотр-текста"><h1>Поля, панели, прокручиваемые окна и просмотр текста</h1></a>
<a class="header" href="print.html#gtkpaned" id="gtkpaned"><h2>GtkPaned</h2></a>
<p>Это контейнеры, которые могут быть ориентированы вертикально или горизонтально,
представляют собой два элемента, размер которых может изменяться.
Размер этих двух элементов может быть изменен простым нажатием и перемещением
разделяющей полосы между ними.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let container = Paned::new(Orientation::Horizontal);
let left_widget = ...;
let right_widget = ...;
container.pack1(&amp;left_widget, true, true);
container.pack2(&amp;right_widget, true, true);
#}</code></pre></pre>
<a class="header" href="print.html#gtkentry" id="gtkentry"><h2>GtkEntry</h2></a>
<p>Элементы позволяют пользовательскому интерфейсу принимать строку текста как
входное значение, что может быть использовано другими виджетами для выполнения
некоторых действий, используя данный текст как входные данные.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let entry = Entry::new();
entry.set_text(&quot;Some Text&quot;);
if let Some(text) = entry.get_text() {
    println!(&quot;{}&quot;, text);
}
#}</code></pre></pre>
<a class="header" href="print.html#gtktextview" id="gtktextview"><h2>GtkTextView</h2></a>
<p>Текстовые панели нужны для двух вещей:</p>
<ul>
<li>способность показывать многострочный текст</li>
<li>возможность пользователю вводить многострочный текст
Текстовая панель может быть настроена так, что ее содержимое нельзя
редактировать, если есть такая необходимость. Также есть возможность
настраивать работу с переносами текста. Текстовые панели не умеют работать
с форматированным текстом, однако вполне могут быть использованы как
редактор кода. Если вы хотите, чтобы текст был показан в виде HTML, смотрите
<strong>GtkWebView</strong>, если же вы хотите получить редактор кода, смотрите
<strong>GtkSourceView</strong>.</li>
</ul>
<blockquote>
<p>Заметьте, что часто бывает лучше создать и привязать <strong>GtkTextBuffer</strong>
к вашему текстовому полю вручную, чтобы получить указатель на буфер,
который вы можете хранить, и избежать непрямого обращения, когда вы
программируете ваш пользовательский интерфейс (UI). Имея указатель на буфер,
можно легко получить доступ к тексту, который содержится в текстовой панели.</p>
</blockquote>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Буфер для текстовой панели с None в качестве параметра, потому что мы не
// собираемся определять никаких текстовых тэгов для этого буфера.
let text_buffer = TextBuffer::new(None);
// После этого мы должны присвоить буфер новой текстовой панели, которая будет
// самостоятельно обновлять себя при добавлении или удалении текста из буфера.
let text_view = TextView::new_with_buffer(&amp;text_buffer);
#}</code></pre></pre>
<p>Извлечение текста из <strong>GtkTextBuffer</strong> требует некоторой сноровки, так что
мы привели пример функции, которую вы можете использовать для того, чтобы
получить содержимое буфера в виде строки (String). Вы можете указать
определенный участок текста, который будет извлечен из буфера.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Получить все содержимое буфера в строковом представлении.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}
#}</code></pre></pre>
<a class="header" href="print.html#gtkscrolledwindow" id="gtkscrolledwindow"><h2>GtkScrolledWindow</h2></a>
<p>Это одноэлементные контейнеры которые предоставляют прокручиваемые окна внутри
них. Часто бывает удобным сочетать их вместе с текстовыми полями, которые
возможно прокручивать. Это как раз то, что мы хотим сделать в этой главе.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let scrolled_window = ScrolledWindow::new(None, None);
scrolled_window.add(&amp;text_view);
#}</code></pre></pre>
<a class="header" href="print.html#horrorshow-html-шаблоны" id="horrorshow-html-шаблоны"><h1>Horrorshow HTML-шаблоны</h1></a>
<p>Хотя это и не связано с разработкой c использованием GTK, пакет horrorshow
предотавляет удобные макроопределения, которые дают возможность эффективно
генерировать HTML-строки в памяти, используя DSL (<em>domain-specific language</em>)
совместно с Rust, который может быть запущен посредством использования символа
(<em>sigil</em>) <code>@</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
#[macro_use]
extern crate horrorshow;
use horrorshow::helper::doctype;

let title = &quot;Title&quot;;
let content = &quot;A string\nwith multiple\n\nlines&quot;;
let html_string = format!(
    &quot;{}&quot;,
    html!{
        : doctype::HTML,
        html {
            head {
                style { : &quot;#style { }&quot; }
            }
            body {
                h1(id=&quot;style&quot;) { : title }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
);
#}</code></pre></pre>
<a class="header" href="print.html#Создаем-структуру-ui" id="Создаем-структуру-ui"><h1>Создаем структуру UI</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<p>Используя первую главу как шаблон и расширяя его, мы должны
продумать дизайн пользовательского интерфейса согласно нашему
видению UI, который представлен выше.</p>
<p>Основные элементы интерфейса, которые стоит взять на заметку - это кнопка
<strong>Post</strong> в заголовочной панели. Внутри нашего окна содержимым содержится
элемент <strong>title</strong>, элемент <strong>tags</strong>, текстовая панель <strong>content</strong> и
текстовая панель <strong>right_pane</strong> для отображения текста в виде HTML-разметки.
Таким образом, структура нашего пользовательского интерфейса выглядит так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct App {
    pub window: Window,
    pub header: Header,
    pub content: Content,
}

pub struct Header {
    pub container: HeaderBar,
    pub post: Button
}

pub struct Content {
    pub container: Paned,
    pub title: Entry,
    pub tags: Entry,
    pub content: TextBuffer,
    pub right_pane: TextBuffer,
}
#}</code></pre></pre>
<p>Заметьте, что контейнер для нашего содержимого будет расположен не в <strong>GtkBox</strong>,
а в <strong>GtkPaned</strong>. Это позволит пользователю перемещать разграничительную полосу
между панелями для того чтобы менять размер панелей по своему усмотрению.
В добавок поля <strong>content</strong> и <strong>right_pane</strong> хранятся как <strong>GtkTextBuffer</strong>,
а не как <strong>GtkTextViews</strong>. Это потому, что мы не будет программировать
панели для просмотра, но будем использовать лежащие в их основе текстовые
буферы, которые связаны с этими панелями.</p>
<a class="header" href="print.html#Написание-программы" id="Написание-программы"><h2>Написание программы</h2></a>
<p>Новым здесь будет то, что мы определим для окон размер по умолчанию, потому
что мы должны иметь разумный размер, с которым пользователь будет
взаимодействовать по умолчанию, чтобы пользователю не приходилось менять размер
окна, чтобы удобнее обозревать его содержимое. Мы также изменяем заголовок на
&quot;HTML Articler&quot;. Кроме этого, все остально должно быть похоже на то, как вы
разрабатываете другие приложения.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl App {
    fn new() -&gt; App {
        // Создадим новое окно верхнего уровня.
        let window = Window::new(WindowType::Toplevel);
        // Создадим заголовочную панель и связанное с ней содержимое.
        let header = Header::new();
        // Создадим элемент для хранения содержимого.
        let content = Content::new();

        // Сделаем заголовочную панель виджетом в панели с названием.
        window.set_titlebar(&amp;header.container);
        // Установим название окна.
        window.set_title(&quot;HTML Articler&quot;);
        // Установим управляющий класс для окна.
        window.set_wmclass(&quot;html-articler&quot;, &quot;HTML Articler&quot;);
        // Иконка, которую программа будет показывать.
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Установить размер окна по умолчанию.
        window.set_default_size(800, 600);
        // Добавим содержимое в окно.
        window.add(&amp;content.container);

        // Запрограммируем, что делать, когда нажата кнопка выхода.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Возвратим главное состояние приложения.
        App { window, header, content }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Реализация-заголовка" id="Реализация-заголовка"><h2>Реализация заголовка</h2></a>
<p>Наша заголовочная панель будет иметь кнопку с надписью <strong>Post</strong>, которая
получит <em>CSS</em>-стиль 'suggested-action' и будет расположена в конце панели.
Название заголовочной панели должна совпадать с именем нашего приложения.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Header {
    fn new() -&gt; Header {
        // Создает контейнер для хранения виджета - заголовочной панели.
        let container = HeaderBar::new();

        // Устанавливает текст для показа в области названия в заголовочной панели.
        container.set_title(&quot;HTML Articler&quot;);
        // Установим элементы управления в области заголовочной панели.
        container.set_show_close_button(true);

        // Создадим кнопку, которая будет выводить HTML-статью.
        let post = Button::new_with_label(&quot;Post&quot;);
        post.get_style_context().map(|x| x.add_class(&quot;suggested-action&quot;));

        container.pack_end(&amp;post);

        // Возвратим заголовок и все его состояние.
        Header { container, post }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Реализация-содержимого" id="Реализация-содержимого"><h2>Реализация содержимого</h2></a>
<p>Это то место, где мы будет тратить большую часть нашего времени, находясь
в приложении. Во-первых, создадим контейнер <strong>GtkPaned</strong>, который будет
содержать левую и правую панели, размер которых изменяем. Нашей правой панелью
будет <strong>GtkTextView</strong>, а правой будет вертикальный <strong>GtkBox</strong>. Заметьте,
мы заинтересованы в том, чтобы получить прямой доступ к тексту внутри буфера
панели для просмотра, так что буфер мы инициализируем перед созданием панели.
Контейнер левой панели будет содержать отступ в <code>5</code> условных единицах,
чтобы они не слеплялись вместе.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Главный контейнер будет содержать левую и правую панели. Левая панели
// предназначена для пользовательского ввода, в то время как правая
// предназначена для показа сгенерированных выходных данных.
let container = Paned::new(Orientation::Horizontal);
let left_pane = Box::new(Orientation::Vertical, 5);
let right_pane = TextBuffer::new(None);
let right_pane_view = TextView::new_with_buffer(&amp;right_pane);
#}</code></pre></pre>
<p>После этого мы создаем элементы <strong>title</strong> и <strong>tags</strong>, в добавок создадим
панель <strong>content</strong>, которую мы будем использовать для построения левой панели.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Левая панель будет состоять из заголовка, элемента с тэгами и текстовой
// панели для просмотра содержимого.
let title = Entry::new();
let tags = Entry::new();
let content = TextBuffer::new(None);
let content_view = TextView::new_with_buffer(&amp;content);
#}</code></pre></pre>
<p>Заметьте, мы также должны хранить размещенную по центру надпись над текстовой
панелью <strong>content</strong>, после которой мы добавим немного заполняющего текста
в элементах, и пояснительные подсказки, которые будут показываться, при наведении
мыши на элементы.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Метка, которую мы будет показывать над элементом с содержимым
// для его описания.
let content_label = Label::new(&quot;Content&quot;);
content_label.set_halign(Align::Center);

// Показывать пользователю текстовые подсказки в полях для ввода. 
title.set_placeholder_text(&quot;Insert Title&quot;);
tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

// Показывать всплывающие подсказки пользователю, которые будут
// проявляться при наведении мыши.
title.set_tooltip_text(&quot;Insert the title of article here&quot;);
tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);
#}</code></pre></pre>
<p>После этого сделаем так, чтобы текстовое поле на правой панели не разрешало
редактирование, и оба текстовых поля должны содержать в себе текст, в которым
переносы произведены по словам (а не по слогам).</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Правая панель не должна разрешать изменять ее содержимое, и оба редактора
// должны производить перенос по целым словам (а не по слогам).
right_pane_view.set_editable(false);
right_pane_view.set_wrap_mode(WrapMode::Word);
content_view.set_wrap_mode(WrapMode::Word);
#}</code></pre></pre>
<p>Сейчас мы должны переносить текстовые поля внутри <strong>GtkScrolledWindows</strong> для
того, чтобы позволить пользователю прокручивать текст, на тот случай, если
имеется больше текста, чем доступно места для просмотра внутри элемента.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Произвести необходимые переносы текста в прокручиваемых окнах.
let content_scroller = ScrolledWindow::new(None, None);
let right_pane_scrolled = ScrolledWindow::new(None, None);
content_scroller.add(&amp;content_view);
right_pane_scrolled.add(&amp;right_pane_view);
#}</code></pre></pre>
<p>Для того, чтобы улучшить пользовательский интерфейс, мы можем добавить поля и
границы.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Настраиваем поля.
left_pane.set_border_width(5);
right_pane_view.set_left_margin(5);
right_pane_view.set_right_margin(5);
right_pane_view.set_top_margin(5);
right_pane_view.set_bottom_margin(5);
content_view.set_left_margin(5);
content_view.set_right_margin(5);
content_view.set_top_margin(5);
content_view.set_bottom_margin(5);
#}</code></pre></pre>
<p>И все, что остается - поместить элеметы внутри соответствующих панелей
и вернуть структуру <strong>Content</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Сначала добавим все в левую панель.
left_pane.pack_start(&amp;title, false, true, 0);
left_pane.pack_start(&amp;tags, false, true, 0);
left_pane.pack_start(&amp;content_label, false, false, 0);
left_pane.pack_start(&amp;content_scroller, true, true, 0);

// После этого добавьте правую и левую панели в контейнер.
container.pack1(&amp;left_pane, true, true);
container.pack2(&amp;right_pane_scrolled, true, true);

Content { container, title, tags, content, right_pane }
#}</code></pre></pre>
<p>Собирая все вместе, мы должны получить следующую реализацию:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl Content {
    fn new() -&gt; Content {
        // Главный контейнер будет содержать левую и правую панели. Левая панель
        // предназначена для пользовательского ввода, а левая панель
        // предназначена для сгенерированных данных.
        let container = Paned::new(Orientation::Horizontal);
        let left_pane = Box::new(Orientation::Vertical, 5);
        let right_pane = TextBuffer::new(None);
        let right_pane_view = TextView::new_with_buffer(&amp;right_pane);

        //Левая панель будет состоять из заголовка, элементов с тэгами и
        // текстовой панели для просмотра содержимого.
        let title = Entry::new();
        let tags = Entry::new();
        let content = TextBuffer::new(None);
        let content_view = TextView::new_with_buffer(&amp;content);

        // Метка, которую мы будем показывать над содержимым для его описания.
        let content_label = Label::new(&quot;Content&quot;);
        content_label.set_halign(Align::Center);

        // Показывать пользователю текстовые подсказки в полях для ввода.
        title.set_placeholder_text(&quot;Insert Title&quot;);
        tags.set_placeholder_text(&quot;Insert Colon-Delimited Tags&quot;);

        // Показывать всплывающие подсказки пользователю, которые будут
        // проявляться при наведении мыши.
        title.set_tooltip_text(&quot;Insert the title of article here&quot;);
        tags.set_tooltip_markup(&quot;&lt;b&gt;tag_one&lt;/b&gt;:&lt;b&gt;tag two&lt;/b&gt;:&lt;b&gt; tag three&lt;/b&gt;&quot;);

        // Правая панель не должна разрешать изменять ее содержимое, и оба редактора
        // должны производить перенос по целым словам (а не по слогам).
        right_pane_view.set_editable(false);
        right_pane_view.set_wrap_mode(WrapMode::Word);
        content_view.set_wrap_mode(WrapMode::Word);

        // Произвести необходимые переносы текста в прокручиваемых окнах.
        let content_scroller = ScrolledWindow::new(None, None);
        let right_pane_scrolled = ScrolledWindow::new(None, None);
        content_scroller.add(&amp;content_view);
        right_pane_scrolled.add(&amp;right_pane_view);

        // Настраиваем отступы.
        left_pane.set_border_width(5);
        right_pane_view.set_left_margin(5);
        right_pane_view.set_right_margin(5);
        right_pane_view.set_top_margin(5);
        right_pane_view.set_bottom_margin(5);
        content_view.set_left_margin(5);
        content_view.set_right_margin(5);
        content_view.set_top_margin(5);
        content_view.set_bottom_margin(5);

        // Сначала добавим все в левую панель.
        left_pane.pack_start(&amp;title, false, true, 0);
        left_pane.pack_start(&amp;tags, false, true, 0);
        left_pane.pack_start(&amp;content_label, false, false, 0);
        left_pane.pack_start(&amp;content_scroller, true, true, 0);

        // После этого добавьте правую и левую панели в контейнер.
        container.pack1(&amp;left_pane, true, true);
        container.pack2(&amp;right_pane_scrolled, true, true);

        Content { container, title, tags, content, right_pane }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Программирование-ui-1" id="Программирование-ui-1"><h1>Программирование UI</h1></a>
<p>Теперь, когда имеются виджеты, которые должны взаимодействовать друг с другом,
вы можете подумать, что данная часть является небольшой, но сложной в реализации.
Если вы так думаете, то вы полностью ошибаетесь, потому что данная часть будет
самой легкой частью программы для реализации. Начнем с функции <code>main</code>, которую
мы возьмем из первой главы в качестве шаблона.</p>
<pre><pre class="playpen"><code class="language-rust">fn main() {
    // Инициализация GTK перед началом работы.
    if gtk::init().is_err() {
        eprintln!(&quot;failed to initialize GTK Application&quot;);
        process::exit(1);
    }

    // Инициализация начального состояния пользовательского интерфейса.
    let app = App::new();

    // Напишите код работы ваших виджетов здесь.

    // Сделать видимыми все виджеты пользовательского интерфейса
    app.window.show_all();

   // Запустим главный цикл событий (_event loop_) GTK.
    gtk::main();
}
</code></pre></pre>
<p>Мы запрограммируем кнопку <strong>Post</strong> так, чтобы она принимала элементы <strong>title</strong>
и <strong>tags</strong>, также как и буфер текстовой панели <strong>content</strong>. Далее мы пропустим
строки из этих виджетов через HTML-макроопределение <em>horrorshow</em> и напишем
получившийся результат в текстовый буфер <strong>right_pane</strong>. Код для программирования
кнопки выглядит так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
{
    // Программирование кнопки **Post** на принятие входных значений из
    // левой панели, произведение необходимого обновление HTML-кода на
    // правой панели. Подготовка к увеличение значения счетчиков...
    let title = app.content.title.clone();
    let tags = app.content.tags.clone();
    let content = app.content.content.clone();
    let right_pane = app.content.right_pane.clone();
    app.header.post.connect_clicked(move |_| {
        let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
        if let (Some(title), Some(tags), Some(content)) = inputs {
            right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
        }
    });
}
#}</code></pre></pre>
<p>Заметьте, получить текста из элемента очень просто. Для этого нужно всего лишь
вызвать метод <strong>get_text()</strong>, который возвращает <strong>Option<String></strong>. Получение
текста из текстового буфера немного сложнее, поэтому вам необходимо использовать
функцию, которая была рекомендована в начале этой главы. Эта функция написана так:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Получить содержимое текстового буфера в виде строки.
fn get_buffer(buffer: &amp;TextBuffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}
#}</code></pre></pre>
<p>Вы также заметите интересный шаблон проектирования (паттерн) в Rust, которая
сильно упростила нам проверку наличия всех входных данных при получение входных
данных, все это произошло перед тем как что-то сделали с входными значениями.
Синтаксис <strong>if let</strong> в Rust работает не только с шаблонами (паттернами),
но и с кортежами (<em>tuple</em>), так что вы можете проверять несколько входных
данных в кортеже одновременно, так же, как вы бы делали это в <strong>match</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let inputs = (title.get_text(), tags.get_text(), get_buffer(&amp;content));
if let (Some(title), Some(tags), Some(content)) = inputs {
    right_pane.set_text(&amp;generate_html(&amp;title, &amp;tags, &amp;content));
}
#}</code></pre></pre>
<p>Нам еще предстоит определить функцию <strong>generate_html</strong>, и это будет
завершающей частью реализации приложения. Самым простым способом
использования макроопределения <strong>html!</strong> является его подстановка в качестве
аргумента в макроопределение <strong>format!</strong>. Наша функция будет выглядеть так,
хотя вы вольны реализовать HTML-макроопределение по своему усмотрению.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
/// Генерирует HTML, который будет показан на правой панели.
fn generate_html(title: &amp;str, tags: &amp;str, content: &amp;str) -&gt; String {
    format!{
        &quot;{}&quot;,
        html!{
            article {
                header {
                    h1 { : &amp;title }
                    div(class=&quot;tags&quot;) {
                        @ for tag in tags.split(':') {
                            div(class=&quot;tag&quot;) { : tag }
                        }
                    }
                }
                @ for line in content.lines().filter(|x| !x.is_empty()) {
                    p { : line }
                }
            }
        }
    }
}
#}</code></pre></pre>
<p>Синтаксис приведенного выше кода должен быть довольно читаемым. Мы создаем
пару тэгов <strong>article</strong>, которая содержит в себе пару тэгов <strong>header</strong> и
параграф <strong>p</strong> для каждой непустой линии из входных данных, полученных из
текстового буфера <strong>content</strong>. Внутри тэгов <strong>header</strong> есть заголовок <strong>h1</strong>,
который использует текст из поля для ввода названия как свой текст. Также там
есть элемент <strong>div</strong>, который содержит список тэгов, разделенных двоеточиями.
<img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<p>Имея все это на своих местах, у вас должна получиться работающая программа,
выглядящая как на изображении.</p>
<a class="header" href="print.html#Заключение-и-обзор-1" id="Заключение-и-обзор-1"><h1>Заключение и обзор</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch03_complete.png" alt="head_pic" /></p>
<p>К данному времени у вас должно сложиться хорошее представление о том, как писать
программы с использованием библиотеки GTK на Rust. К текущему моменту вы должны
знать, как делать следующее:</p>
<ul>
<li>создавать, получать, присваивать значения объектам <strong>Label</strong></li>
<li>создавать, получать, присваивать значения объектам <strong>Entries</strong></li>
<li>создавать, получать, присваивать значения объектам <strong>TextBuffer</strong></li>
<li>создавать, присваивать буферы объектам <strong>TextViews</strong></li>
<li>создавать, настраивать стили внешнего вида, программировать объекты <strong>Button</strong></li>
<li>присваивать элементы объектам <strong>Box</strong> и контейнерам <strong>Paned</strong></li>
<li>устанавливать отступы и поля на виджетах</li>
<li>работать с внешним состоянием</li>
</ul>
<a class="header" href="print.html#Практические-задачи" id="Практические-задачи"><h2>Практические задачи</h2></a>
<a class="header" href="print.html#Простой-редактор-common-mark" id="Простой-редактор-common-mark"><h1>Простой редактор Common Mark</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch04_complete.png" alt="head_pic" /></p>
<blockquote>
<p>Исходный код для этой главы находится <a href="https://github.com/ruRust/gtk-rust-by-example/tree/master/src/source_code/simple_editor_common_mark">здесь</a>.</p>
</blockquote>
<p>В данной главе мы создадим полезную программу для редактирования текста с
синтаксисом Markdown, в частности, версии Common Mark, и покажем этот текст
в реальном времени, с помощью предпросмотра HTML.</p>
<p>Мы также будем использовать окно для открытия и сохранения файлов,
будем хешировать буфер, чтобы знать, когда кнопка Save должна быть
активирована. Когда это будет завершено, вы должны будете понимать не только
как использовать пакет <strong>gtk</strong>, но и <strong>gdk</strong>, <strong>pango</strong>, <strong>webkit2gtk</strong>,
<strong>sourceview</strong>.</p>
<blockquote>
<p>Эта глава была написана использованием готовой программы, которую мы
собираемся собрать. Можно сказать, что это обучающее пособие реализует само
себя.</p>
</blockquote>
<blockquote>
<p>HTML можно писать внутри данного диалекта Markdown. Это позволяет смешивать
HTML и Markdown в одном редакторе, отображение будет показываться справа.</p>
</blockquote>
<a class="header" href="print.html#Исходные-требования" id="Исходные-требования"><h2>Исходные требования</h2></a>
<p>Очень полезно знать, как использовать типы <strong>RwLock</strong> и <strong>Mutex</strong> перед тем
как продвигаться дальше, так как данные типы будут использоваться для работы с
внешним состоянием. Это позволит переменным быть заимствованными по изменяемой
ссылке в нескольких потоках и замыканиях, тогда как в другом случае эти
переменные были бы неизменяемыми.</p>
<a class="header" href="print.html#Зависимости" id="Зависимости"><h2>Зависимости</h2></a>
<p>Ваши зависимости должны быть следующими:</p>
<pre><code class="language-toml">[dependencies]
gdk = &quot;0.6&quot;
horrorshow = &quot;0.6.2&quot;
pango = &quot;0.2.0&quot;
pulldown-cmark = &quot;0.1.0&quot;
tiny-keccak = &quot;1.4.0&quot;
webkit2gtk = &quot;0.2&quot;

[dependencies.sourceview]
features = [&quot;v3_18&quot;]
version = &quot;0.2&quot;

[dependencies.gtk]
features = [&quot;v3_22&quot;]
version = &quot;0.2&quot;
</code></pre>
<a class="header" href="print.html#puldown-cmark" id="puldown-cmark"><h3>puldown-cmark</h3></a>
<p>Кто-то может заметить, что мы добавили новые пакеты. В Google можно узнать
про пакет <a href="https://github.com/google/pulldown-cmark">pulldown-cmark</a>, который предоставляет хороший парсер CommonMark
и поэтому дает возможность преобразовывать Markdown в HTML.</p>
<a class="header" href="print.html#tiny-keccak" id="tiny-keccak"><h3>tiny-keccak</h3></a>
<p>Мы будем использовать алгоритм хеширования для того, чтобы делать кнопку Save
активной или неактивной. Проще говоря, мы будем хешировать буфер при каждом
нажатии клавиш и сравнивать полученный хеш с сохраненным. Если хеши совпадают,
то кнопка Save должна быть активной, иначе - неактивной.</p>
<a class="header" href="print.html#sourceview" id="sourceview"><h3>sourceview</h3></a>
<p>Благодаря этому пакету у нас появится доступ к виджету <strong>GtkSourceView</strong>,
который мы будем использовать для создания редактора кода, используемом для
редактированяи Markdown.</p>
<a class="header" href="print.html#webkit2gtk" id="webkit2gtk"><h3>webkit2gtk</h3></a>
<p>Благодаря этому пакету у нас появится виджет <strong>GtkWebView</strong>, который
будет показывать &quot;живое&quot; представление нашего редактируемого Markdown.</p>
<a class="header" href="print.html#pango" id="pango"><h3>pango</h3></a>
<p>Благодаря этому пакету мы сможем изменять шрифт в <strong>GtkSourceView</strong>.</p>
<a class="header" href="print.html#gdk" id="gdk"><h3>gdk</h3></a>
<p>Мы будем использовать его для обработки некоторых нажатий клавиш.</p>
<a class="header" href="print.html#Выбор-файла-просмотр-кода-и-web-страниц" id="Выбор-файла-просмотр-кода-и-web-страниц"><h1>Выбор файла, просмотр кода и web-страниц</h1></a>
<a class="header" href="print.html#gtkwebview" id="gtkwebview"><h2>GtkWebView</h2></a>
<p>![pic_gtkwebview]: https://mmstick.github.io/gtkrs-tutorials/images/web_view.png</p>
<p>Этот виджет, предоставляемый [webkit2gtk][], который содержит прокручиваемое
окно и предоставляет встроенный web-движок для рендеринга HTML. Данный элемент
нужен для показа отрендеренного HTML, полученного из текста Markdown в буфере.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let context = WebContext::get_default().unwrap();
let webview = WebView::new_with_context(&amp;context);
#}</code></pre></pre>
<p>Мы поместим HTML, который получен посредством использования пакета horrowshow,
в web-панель напрямую, с помощью метода <code>load_html()</code>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
webview.load_html(&amp;html, None);
#}</code></pre></pre>
<a class="header" href="print.html#gtksourceview" id="gtksourceview"><h2>GtkSourceView</h2></a>
<p>![pic_gtkwebview]: https://mmstick.github.io/gtkrs-tutorials/images/source_view.png
Это предоставляемый нам усовершенствованный <strong>GtkTextView</strong>. Однако не
ожидайте слишком многого от него, потому что на текущий момент он достаточно
примитивен.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let source_buffer = Buffer::new(None);
let source_view = View::new_with_buffer(&amp;source_buffer);
#}</code></pre></pre>
<p>Настройки по умолчанию не отличаются от соответствующих настроек <strong>GtkTextView</strong>,
поэтому вам нужно будет самостоятельно настроить виджет.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
source_view.set_show_line_numbers(true);
source_view.set_monospace(true);
let font = FontDescription::from_string(&quot;monospace 11&quot;);
WidgetExt::override_font(&amp;source_view, &amp;font);
#}</code></pre></pre>
<a class="header" href="print.html#gtkfilechooserdialog" id="gtkfilechooserdialog"><h2>GtkFileChooserDialog</h2></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/file_chooser_dialog.png" alt="pic_GtkFileChooserDialog" />
<strong>GtkFileChooserDialogs</strong> будет использоваться для программирования поведения
кнопок для открытия/закрытия/сохранения файлов. Они будут открывать окно, где
вы сможете выбрать файл. Важный момент: <strong>GtkFileChooserDialogs</strong> не
использует возможности типажа <strong>Drop</strong>. Но беспокоиться не стоит, все нужное
мы реализуем самостоятельно.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Создать новое диалоговое окно выбора файла для открытия.
let open_dialog = FileChooserDialog::new(
    Some(&quot;Open&quot;),
    Some(&amp;Window::new(WindowType::Popup)),
    FileChooserAction::Open,
);

// Добавить кнопки **Cancel**, **Save** в это диалоговое окно.
open_dialog.add_button(&quot;Cancel&quot;, ResponseType::Cancel.into());
open_dialog.add_button(&quot;Open&quot;, ResponseType::Ok.into());

// Открыть созданное диалоговое окно и принять полученный результат.
if open_dialog.run() == ResponseType::Ok.into() {
    if let Some(filename) = open_dialog.get_filename() {
        // Сделать что-то с полученным `PathBuf`.
    }
}

// Уничтожить диалоговое окно. Будьте внимательны: не возвращайтесь из
// функции, не уничтожив прежде диалоговое окно.
open_dialog.destroy();
#}</code></pre></pre>
<a class="header" href="print.html#Настройка-модулей" id="Настройка-модулей"><h1>Настройка модулей</h1></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch04_mod_diagram.png" alt="head_pic" /></p>
<p>В данной главе мы начнем использовать модули, чтобы разделить код на отдельные
части. Следуя приведенной выше диаграмме мы отделим GTK-специфичную часть кода
от остального кода.</p>
<ul>
<li>модуль <strong>ui</strong> будет содержать весь код, относящийся к построению и выполнению
GTK-программы.</li>
<li>модуль <strong>preview</strong> генерирует HTML из предоставленного Markdown.</li>
<li>модуль <strong>state</strong> содержит типы, которые используются для работы с внешним
состоянием.</li>
</ul>
<a class="header" href="print.html#Создание-модулей" id="Создание-модулей"><h2>Создание модулей</h2></a>
<p><img src="https://mmstick.github.io/gtkrs-tutorials/images/ch04_mod_structure.png" alt="creating_modules" /></p>
<p>Модули <strong>preview</strong> и <strong>state</strong> относительно простые, они могут быть
представлены двумя Rust-файлами: <strong>preview.rs</strong> и <strong>state.rs</strong>. Модуль <strong>ui</strong>
будет гораздо более сложным, содержа в себе подмодули. У нас будет директория
<strong>ui</strong> где будет точка входа в модуль в виде файла <strong>mod.rs</strong> внутри
директории.</p>
<a class="header" href="print.html#Файл-mainrs" id="Файл-mainrs"><h2>Файл <strong>main.rs</strong></h2></a>
<p>Как только мы настроим основные модули, мы свяжем всё воедино и соединим с
главной точкой входа в программу - <strong>main.rs</strong>. Первоначальная версия будет
выглядеть так:</p>
<pre><pre class="playpen"><code class="language-rust">extern crate gdk;
extern crate gtk;
#[macro_use]
extern crate horrorshow;
extern crate pango;
extern crate pulldown_cmark;
extern crate sourceview;
extern crate tiny_keccak;
extern crate webkit2gtk;

pub mod preview;
pub mod state;
pub mod ui;

use ui::App;

fn main() {
    // Инициализировать исходное состояние пользовательского интерфейса.
    App::new()
        // &quot;Соединить&quot; события с пользовательским интерфейсом.
        .connect_events()
        // Показать пользовательский интерфейс и запустить программу.
        .then_execute();
}
</code></pre></pre>
<p>Вы можете заметить отличия от приведенного в прошлой главе кода. В этой главе
мы будем использовать паттерн <strong>Builder</strong> для подготовки к работе и исполнению
нашей программы. Данный паттерн здесь очень кстати, так как во время
компиляции может предотвратить появление ошибок связанных с API.</p>
<p>Метод <code>App::new()</code> создает новый <strong>App</strong>, который мы передадим в метод
<code>connect_events()</code>. Данный метод преобразует <strong>App</strong> в <strong>ConnectedApp</strong>,
который реализует <code>then_execute()</code>, показывающий пользовательский интерфейс и
выполняющий главный цикл событий. </p>
<a class="header" href="print.html#Модуль-uimiscrs" id="Модуль-uimiscrs"><h1>Модуль ui/misc.rs</h1></a>
<p>Мы реализуем несколько вспомогательных методов, которые при необходимости
будут использоваться в проекте. Это две функции: одна для извлечения текста из
<strong>GtkSourceBuffer</strong>, другая для установки названия у <strong>GtkHeaderBar</strong> с
заданным <strong>Path</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use gtk::*;
use sourceview::*;
use std::path::Path;

/// Присвоить заголовку в заголовочной панели ссылку на строковое
/// представление пути к файлу. 
pub fn set_title(headerbar: &amp;HeaderBar, path: &amp;Path) {
    if let Some(filename) = path.file_name() {
        let filename: &amp;str = &amp;filename.to_string_lossy();
        headerbar.set_title(filename);
    }
}

/// Получить все внутреннее содержимое данного текстового буфера в виде
/// строки.
pub fn get_buffer(buffer: &amp;Buffer) -&gt; Option&lt;String&gt; {
    let start = buffer.get_start_iter();
    let end = buffer.get_end_iter();
    buffer.get_text(&amp;start, &amp;end, true)
}
#}</code></pre></pre>
<a class="header" href="print.html#Создание-структуры-пользовательского-интерфейса" id="Создание-структуры-пользовательского-интерфейса"><h1>Создание структуры пользовательского интерфейса</h1></a>
<p>TODO: вставить ссылку на картинку</p>
<a class="header" href="print.html#Реализация-модуля-пользовательского-интерфейса-uimodrs" id="Реализация-модуля-пользовательского-интерфейса-uimodrs"><h2>Реализация модуля пользовательского интерфейса (ui/mod.rs)</h2></a>
<p>Теперь, когда относящийся к UI код перемещен в свой собственный модуль,
очень важно объявить подмодули, которые данный модуль будет импортировать.
Также важно объявить типы и функции, который данный модуль будет
экспортировать.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
mod app;
mod content;
mod dialogs;
mod header;
pub mod misc;
pub mod save;

pub use self::app::App;
pub use self::content::Content;
pub use self::dialogs::{OpenDialog, SaveDialog};
pub use self::header::Header;
#}</code></pre></pre>
<p>Как можно заметить выше, мы создаем следующие модули: <strong>app.rs</strong>,
<strong>content.rs</strong>, <strong>dialogs.rs</strong>, <strong>save.rs</strong>, <strong>header.rs</strong>, <strong>misc.rs</strong>.</p>
<a class="header" href="print.html#Реализация-структуры-программы-uiapprs" id="Реализация-структуры-программы-uiapprs"><h2>Реализация структуры программы (ui/app.rs)</h2></a>
<p>Данная часть должна быть более-менее простой, так как использует код, подобный
тому, что был задействован в предыдущих главах. С той разницей, что мы
переместили инициализацию GTK в начало <strong>App</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use gtk;
use gtk::*;
use super::Header;
use super::Content;

pub struct App {
    pub window:  Window,
    pub header:  Header,
    pub content: Content,
}

impl App {
    pub fn new() -&gt; App {
        // Инициализация GTK.
        if gtk::init().is_err() {
            eprintln!(&quot;failed to initialize GTK Application&quot;);
            process::exit(1);
        }

        // Создать окно верхнего уровня.
        let window = Window::new(WindowType::Toplevel);
        // Создать заголовочную панель и связанное с ней содержимое.
        let header = Header::new();
        // Создать контейнер для хранения содержимого и виджетов.
        let content = Content::new();

        // Сделать заголовочную панель виджетом, содержащим название.
        window.set_titlebar(&amp;header.container);
        // Установить заголовок окна.
        window.set_title(&quot;Markdown Editor&quot;);
        // Установить класс менеджера окна.
        window.set_wmclass(&quot;md-editor&quot;, &quot;Markdown Editor&quot;);
        // Иконка программы.
        window.set_default_size(800, 600);
        Window::set_default_icon_name(&quot;iconname&quot;);
        // Добавить содержимое вовнутрь окна.
        window.add(&amp;content.container);

        // Запрограммировать поведение кнопки выхода.
        window.connect_delete_event(move |_, _| {
            main_quit();
            Inhibit(false)
        });

        // Возвратить структуру программы.
        App { window, header, content }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Реализация-структуры-заголовка-uiheaderrs" id="Реализация-структуры-заголовка-uiheaderrs"><h2>Реализация структуры заголовка (ui/header.rs)</h2></a>
<p>Данную структуру будет реализовать ещё проще. Мы реализуем кнопки <strong>Open</strong>,
<strong>Save</strong>, <strong>Save As</strong>, которые будут находиться в заголовке. Мы будем
использовать мнемоники, так что одна из букв в названии кнопок будет
становиться подчеркнутой при нажатии на клавишу <strong>Alt</strong>, так что пользователь
сможет выбрать нужную кнопку.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use gtk::*;

pub struct Header {
    pub container: HeaderBar,
    pub open:      Button,
    pub save:      Button,
    pub save_as:   Button,
}

impl Header {
    pub fn new() -&gt; Header {
        // Создать контейнер для хранения главной заголовочной панели. 
        let container = HeaderBar::new();

        // Установить текст, который будет показывать в заголовке
        // заголовочной панели.
        container.set_title(&quot;Markdown Editor&quot;);
        // Включить элементы управления окна внутри заголовочной панели.
        container.set_show_close_button(true);

        let open = Button::new_with_mnemonic(&quot;_Open&quot;);
        let save = Button::new_with_mnemonic(&quot;_Save&quot;);
        let save_as = Button::new_with_mnemonic(&quot;Save _As&quot;);
        container.pack_start(&amp;open);
        container.pack_end(&amp;save_as);
        container.pack_end(&amp;save);

        // Возвратить заголовок и все его внутреннее содержимое.
        Header { container, open, save, save_as }
    }
}
#}</code></pre></pre>
<a class="header" href="print.html#Реалиазация-структуры-содержимого-uicontentrs" id="Реалиазация-структуры-содержимого-uicontentrs"><h2>Реалиазация структуры содержимого (ui/content.rs)</h2></a>
<p>Здесь мы начнем использовать <strong>GtkWebViews</strong>, <strong>GtkSourceViews</strong>.</p>
<a class="header" href="print.html#Создание-просмотра-web" id="Создание-просмотра-web"><h3>Создание просмотра web</h3></a>
<p>Создание просмотра web очень легко создать. Выполняя следующий код, вы получите
панель для просмотра web, которую вы можете внедрить в ваш пользовательский
интерфейс так же, как вы можете это сделать с другими виджетами.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Create a the WebView for the preview pane.
let context = WebContext::get_default().unwrap();
let preview = WebView::new_with_context(&amp;context);
#}</code></pre></pre>
<p>Данный просмотр web прокручиваем, так что эту функциональность не нужно
реализовывать самостоятельно.</p>
<a class="header" href="print.html#Создаем-и-настраиваем-просмотр-кода" id="Создаем-и-настраиваем-просмотр-кода"><h3>Создаем и настраиваем просмотр кода</h3></a>
<p>Просмотр кода являются более сложной реализацией, потому что он требуют
дополнительной настройки. Мы попытаемся получить следующий результат:</p>
<ul>
<li>Табуляция должна быть размером в 4 пробела</li>
<li>Просмотрщик должен показывать номера строк</li>
<li>Будем использовать шрифт по умолчанию - <em>monospaced</em>, размер - 11</li>
<li>Подсветка синтаксиса Markdown</li>
<li>Попытка использовать тему Builder, если не получится - тему Classic</li>
</ul>
<p>Начнем со структуры <strong>Source</strong>.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
pub struct Source {
    pub container: ScrolledWindow,
    pub view:      View,
    pub buff:      Buffer,
}

impl Source {
    fn new() -&gt; Source {

    }
}
#}</code></pre></pre>
<p>После этого создадим буфер и представление для просмотра, это делается
так же, как и создание простого текстового буфера и представления для
просмотра. Как только это сделано, мы поместим представление вовнутрь
прокручиваемого окна.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Создать SourceView для редактора на левой панели.
let buff = Buffer::new(None);
let view = View::new_with_buffer(&amp;buff);
let container = ScrolledWindow::new(None, None);
container.add(&amp;view);
#}</code></pre></pre>
<p>Установим настройки, используя функцию, принимающую представление и буфер:</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
fn configure_source_view(view: &amp;View, buff: &amp;Buffer) {
    view.set_show_line_numbers(true);
    view.set_monospace(true);
    view.set_insert_spaces_instead_of_tabs(true);
    view.set_indent_width(4);
    view.set_smart_backspace(true);
    view.set_right_margin(100);
    view.set_left_margin(10);
    view.set_show_right_margin(true);
    view.set_background_pattern(BackgroundPatternType::Grid);
    // TODO: следующий релиз пакета GTK
    // view.set_input_hints(InputHints::SPELLCHECK + InputHints::WORD_COMPLETION);
}
#}</code></pre></pre>
<p>Мы можем использовать пакет <strong>pango</strong> для изменения шрифта в представлении.
Заметьте, нам необходимо объявить типаж, чтобы понять откуда появился метод
<code>override_font</code>. Возможно, будущее обновление GTK Rust API займется решением
этого вопроса.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Настраивает шрифт, используемый в панели с кодом. По умолчанию используется
// Monospaced, размер - 11. Когда будем изменять шрифт, нужно вручную указать
// типаж, в котором находится нужный метод.
let font = FontDescription::from_string(&quot;monospace 11&quot;);
WidgetExt::override_font(&amp;view, &amp;font);
#}</code></pre></pre>
<p>Включим подсветку синтаксиса Markdown по умолчанию. Используемые языки
извлекаются из <strong>LanguageManager</strong>. Язык будет присвоен напрямую буферу,
а не представлению.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
// Включить подсветку Markdown
LanguageManager::new()
    .get_language(&quot;markdown&quot;)
    .map(|markdown| buff.set_language(&amp;markdown));
#}</code></pre></pre>
<p>Укажем используемую схему.</p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
let manager = StyleSchemeManager::new();
    manager
        .get_scheme(&quot;Builder&quot;)
        .or(manager.get_scheme(&quot;Classic&quot;))
        .map(|theme| buff.set_style_scheme(&amp;theme));
#}</code></pre></pre>
<a class="header" href="print.html#Полный-исходный-код" id="Полный-исходный-код"><h2>Полный исходный код</h2></a>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use gtk::*;
use pango::*;
use sourceview::*;
use webkit2gtk::*;

pub struct Content {
    pub container: Paned,
    pub source:    Source,
    pub preview:   WebView,
}

pub struct Source {
    pub container: ScrolledWindow,
    pub view:      View,
    pub buff:      Buffer,
}

impl Content {
    pub fn new() -&gt; Content {
        // Создать контейнер для хранения главного содержимого
        let container = Paned::new(Orientation::Horizontal);
        let source = Source::new();

        // Создать WebView для предыдущей панели.
        let context = WebContext::get_default().unwrap();
        let preview = WebView::new_with_context(&amp;context);

        // Упакуем
        container.pack1(&amp;source.container, true, true);
        container.pack2(&amp;preview, true, true);

        // Сделать так, чтобы две панели имели одинаковый размер - половина
        // контейнера, в котором они находятся.
        source.container.set_size_request(100, -1);
        preview.set_size_request(100, -1);

        Content { container, source, preview }
    }
}

impl Source {
    pub fn new() -&gt; Source {
        // Создать SourceView для редактора на левой панели.
        let buff = Buffer::new(None);
        let view = View::new_with_buffer(&amp;buff);
        let container = ScrolledWindow::new(None, None);
        container.add(&amp;view);

        configure_source_view(&amp;view, &amp;buff);

        Source { container, buff, view }
    }
}

fn configure_source_view(view: &amp;View, buff: &amp;Buffer) {
    WidgetExt::override_font(view, &amp;FontDescription::from_string(&quot;monospace&quot;));

    LanguageManager::new()
        .get_language(&quot;markdown&quot;)
        .map(|markdown| buff.set_language(&amp;markdown));

    let manager = StyleSchemeManager::new();
    manager
        .get_scheme(&quot;Builder&quot;)
        .or(manager.get_scheme(&quot;Classic&quot;))
        .map(|theme| buff.set_style_scheme(&amp;theme));

    view.set_show_line_numbers(true);
    view.set_monospace(true);
    view.set_insert_spaces_instead_of_tabs(true);
    view.set_indent_width(4);
    view.set_smart_backspace(true);
    view.set_right_margin(100);
    view.set_left_margin(10);
    view.set_show_right_margin(true);
    view.set_background_pattern(BackgroundPatternType::Grid);
    // TODO: следующий релиз пакета GTK
    // view.set_input_hints(InputHints::SPELLCHECK + InputHints::WORD_COMPLETION);
}
#}</code></pre></pre>
<a class="header" href="print.html#Работа-с-внешним-состоянием" id="Работа-с-внешним-состоянием"><h1>Работа с внешним состоянием</h1></a>
<p>Данная часть рассматривает модуль <strong>state.rs</strong>, который будет содержать в себе
типы, используемые для работы с не-GTK внешним состоянием. Это будет очень
просто, потому что Markdown-редактор не хранит большой объем данных во внешнем
хранилище.</p>
<a class="header" href="print.html#Что-нам-нужно" id="Что-нам-нужно"><h2>Что нам нужно?</h2></a>
<p>Имеются два ключевых компонента, которые должны нас заботить в течение времени
жизни программы</p>
<ul>
<li>путь к редактируемому файлу</li>
<li>хеш-сумма содержимого файла для сравнения текущего содержимого редактора с
содержимым файла для того чтобы знать, когда активировать/деактивировать
кнопку <strong>Save</strong>.</li>
</ul>
<a class="header" href="print.html#activemetadata" id="activemetadata"><h2>ActiveMetadata</h2></a>
<p>Так появилась структура <strong>ActiveMetadata</strong>. Она содержит <strong>PathBuf</strong>,
используемый для хранения пути к редактируемому файлу, и 64-байтный
хеш, который будет сгенерирован функцией <strong>keccak512()</strong> из пакета
<a href="https://docs.rs/tiny-keccak/1.4.0/tiny_keccak/fn.keccak512.html">tiny-keccak</a></p>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
use std::path::{Path, PathBuf};
use tiny_keccak::keccak512;

pub struct ActiveMetadata {
    path: PathBuf,
    sum:  [u8; 64],
}
#}</code></pre></pre>
<p>Реализация методов для этого типа будет простой. Мы должны создать:</p>
<ul>
<li>новый экземпляр метаданных</li>
<li>функцию для получения ссылки на путь к файлу</li>
<li>функцию для проверки того, что хеш-сумма содержимого в редакторе такая же,
как и хранимая в структуре, функцию для обновления значения хеш-суммы при
сохранении файла</li>
</ul>
<pre><pre class="playpen"><code class="language-rust">
# #![allow(unused_variables)]
#fn main() {
impl ActiveMetadata {
    pub fn new(path: PathBuf, data: &amp;[u8]) -&gt; ActiveMetadata {
        ActiveMetadata { path, sum: keccak512(data) }
    }

    pub fn get_path&lt;'a&gt;(&amp;'a self) -&gt; &amp;'a Path { &amp;self.path }

    pub fn get_dir(&amp;self) -&gt; Option&lt;PathBuf&gt; { self.path.parent().map(|p| p.to_path_buf()) }

    pub fn is_same_as(&amp;self, data: &amp;[u8]) -&gt; bool { &amp;keccak512(data)[..] == &amp;self.sum[..] }

    pub fn set_sum(&amp;mut self, data: &amp;[u8]) { self.sum = keccak512(data); }
}
#}</code></pre></pre>

                </div>

                <!-- Mobile navigation buttons -->
                

                

            </div>

            

            

        </div>


        <!-- Local fallback for Font Awesome -->
        <script>
            if ($(".fa").css("font-family") !== "FontAwesome") {
                $('<link rel="stylesheet" type="text/css" href="_FontAwesome/css/font-awesome.css">').prependTo('head');
            }
        </script>

        <!-- Livereload script (if served using the cli tool) -->
        

        

        

        
        <script>
            $(document).ready(function() {
                window.print();
            })
        </script>
        

        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS script -->
        

    </body>
</html>
